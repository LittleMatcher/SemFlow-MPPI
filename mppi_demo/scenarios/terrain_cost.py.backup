"""
Terrain Cost Scenario - 地形代价场景

包含三个不同地形区域：
1. 水泥路面（Concrete）：代价最低，最优通行
2. 草地（Grass）：代价中等，可通行但不推荐
3. 沼泽地（Swamp）：代价很高，应尽量避免

同时包含类似圣诞市场的障碍物布局
"""
import numpy as np
import sys
import os
from typing import List, Tuple

parent_dir = os.path.dirname(os.path.dirname(__file__))
sys.path.insert(0, parent_dir)

from mppi_core.environment_2d import Environment2D, Circle, Rectangle


class TerrainRegion:
    """地形区域定义"""
    def __init__(self, vertices: np.ndarray, cost_multiplier: float, name: str):
        """
        Args:
            vertices: 区域顶点坐标 (N, 2)
            cost_multiplier: 地形代价倍数（1.0=正常，>1更贵）
            name: 区域名称
        """
        self.vertices = np.asarray(vertices, dtype=np.float64)
        self.cost_multiplier = float(cost_multiplier)
        self.name = name
    
    def contains_point(self, point: np.ndarray) -> bool:
        """判断点是否在区域内（射线法）"""
        x, y = point[0], point[1]
        n = len(self.vertices)
        inside = False
        
        p1x, p1y = self.vertices[0]
        for i in range(1, n + 1):
            p2x, p2y = self.vertices[i % n]
            if y > min(p1y, p2y):
                if y <= max(p1y, p2y):
                    if x <= max(p1x, p2x):
                        if p1y != p2y:
                            xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x
                        if p1x == p2x or x <= xinters:
                            inside = not inside
            p1x, p1y = p2x, p2y
        
        return inside


def create_terrain_cost_environment():
    """
    创建带地形代价的环境
    
    优化后的布局设计：
    - 中央：沼泽地带（极高代价10×）- 形成"捷径诱惑"
    - 左右两侧：水泥路面走廊（低代价1×）- 绕路但总成本低
    - 四角：草地区域（中等代价3×）
    - 起点(-8,-8)到终点(8,8)的直线会穿过沼泽，但绕路走水泥才是最优
    
    这种设计能明显展示MPPI选择地形的智能：
    - 直线距离：~22.6m，但穿过沼泽，成本≈226
    - 绕路走水泥：~26-28m，但成本≈26-28（节省80%+）
    
    Returns:
        env: 环境对象
        terrain_regions: 地形区域列表
        start: 起点
        goal: 终点
        bounds: 边界
    """
    bounds = (-10, 10, -10, 10)
    env = Environment2D(bounds=bounds)
    
    # === 定义三个地形区域 ===
    terrain_regions = []
    
    # 1. 沼泽地带（中央窄带，对角线分布，宽度±2）
    # 关键：窄一点才能让绕路更有优势
    swamp_vertices = np.array([
        [-2, -5],
        [2, -5],
        [5, -2],
        [5, 2],
        [2, 5],
        [-2, 5],
        [-5, 2],
        [-5, -2]
    ])
    terrain_regions.append(TerrainRegion(
        swamp_vertices, 
        cost_multiplier=10.0,  # 10倍代价！沼泽地极度昂贵
        name="Swamp"
    ))
    
    # 2. 水泥路面（两侧宽走廊）
    # 左下角水泥走廊（更大范围）
    concrete_left_vertices = np.array([
        [-10, -10],
        [-5, -10],
        [-10, -5]
    ])
    terrain_regions.append(TerrainRegion(
        concrete_left_vertices,
        cost_multiplier=1.0,  # 基准代价
        name="Concrete"
    ))
    
    # 右上角水泥走廊（更大范围）
    concrete_right_vertices = np.array([
        [2, 10],
        [10, 10],
        [10, 2]
    ])
    terrain_regions.append(TerrainRegion(
        concrete_right_vertices,
        cost_multiplier=1.0,
        name="Concrete"
    ))
    
    # 3. 草地（四个角落，包括起点和终点）
    # 左下角 - 包含起点
    grass_bl_vertices = np.array([
        [-10, -10],
        [-7, -10],
        [-10, -7]
    ])
    terrain_regions.append(TerrainRegion(
        grass_bl_vertices,
        cost_multiplier=3.0,  # 3倍代价
        name="Grass"
    ))
    
    # 右上角 - 包含终点
    grass_tr_vertices = np.array([
        [7, 10],
        [10, 10],
        [10, 7]
    ])
    terrain_regions.append(TerrainRegion(
        grass_tr_vertices,
        cost_multiplier=3.0,
        name="Grass"
    ))
    
    # === 添加障碍物（类似圣诞市场布局）===
    # 下部区域
    env.add_rectangle_obstacle(-2.5, -1.5, -9.0, -7.5)
    env.add_rectangle_obstacle(0.5, 1.5, -9.0, -7.5)
    
    # 中下部
    env.add_rectangle_obstacle(-2.8, -1.3, -6.0, -4.5)
    env.add_rectangle_obstacle(1.3, 2.8, -6.0, -4.5)
    
    # 中部障碍（形成S形通道）
    env.add_rectangle_obstacle(-2.5, -1.0, -2.5, -1.0)
    env.add_rectangle_obstacle(1.0, 2.5, -2.5, -1.0)
    
    # 中央区域
    env.add_rectangle_obstacle(-2.8, -1.5, 1.0, 2.5)
    env.add_rectangle_obstacle(1.5, 2.8, 1.0, 2.5)
    
    # 中上部
    env.add_rectangle_obstacle(-2.5, -1.0, 4.5, 6.0)
    env.add_rectangle_obstacle(1.0, 2.5, 4.5, 6.0)
    
    # 上部区域
    env.add_rectangle_obstacle(-2.0, -0.8, 7.5, 9.0)
    env.add_rectangle_obstacle(0.8, 2.0, 7.5, 9.0)
    
    # 圆形障碍物
    env.add_circle_obstacle(np.array([-2.0, -3.5]), 0.35)
    env.add_circle_obstacle(np.array([2.0, -3.5]), 0.35)
    env.add_circle_obstacle(np.array([0.0, 0.0]), 0.3)
    env.add_circle_obstacle(np.array([-2.0, 3.5]), 0.35)
    env.add_circle_obstacle(np.array([2.0, 3.5]), 0.35)
    
    # 边界小障碍（防止贴边走）
    env.add_rectangle_obstacle(-9.5, -9.0, -5.0, -4.0)
    env.add_rectangle_obstacle(9.0, 9.5, 4.0, 5.0)
    
    # 起点和终点：对角线布局，直线穿过沼泽中心
    start = np.array([-8.0, -8.0])  # 左下角草地区域
    goal = np.array([8.0, 8.0])     # 右上角草地区域
    # 直线距离约22.6m，但穿过沼泽成本极高
    # 最优路径应该绕过沼泽，走左下→左边→右上或左下→右边→右上
    
    return env, terrain_regions, start, goal, bounds


def get_terrain_cost_at_point(point: np.ndarray, terrain_regions: List[TerrainRegion]) -> float:
    """
    获取某点的地形代价倍数
    
    Args:
        point: 位置 (2,)
        terrain_regions: 地形区域列表
    Returns:
        cost_multiplier: 地形代价倍数
    """
    for region in terrain_regions:
        if region.contains_point(point):
            return region.cost_multiplier
    return 1.0  # 默认代价


def get_terrain_cost_batch(points: np.ndarray, terrain_regions: List[TerrainRegion]) -> np.ndarray:
    """
    批量获取地形代价
    
    Args:
        points: 位置数组 (N, 2)
        terrain_regions: 地形区域列表
    Returns:
        costs: 代价倍数数组 (N,)
    """
    costs = np.ones(len(points))
    for i, point in enumerate(points):
        costs[i] = get_terrain_cost_at_point(point, terrain_regions)
    return costs


if __name__ == "__main__":
    # 简单测试
    env, terrain_regions, start, goal, bounds = create_terrain_cost_environment()
    print(f"Environment created with {len(env.obstacles)} obstacles")
    print(f"Terrain regions: {[r.name for r in terrain_regions]}")
    print(f"Start: {start}, Goal: {goal}")
    
    # 测试地形代价
    test_points = [
        np.array([-5.0, 0.0]),  # 沼泽
        np.array([0.0, 0.0]),   # 水泥
        np.array([5.0, 0.0])    # 草地
    ]
    for p in test_points:
        cost = get_terrain_cost_at_point(p, terrain_regions)
        print(f"Point {p}: terrain cost = {cost}")
