# CFM FlowMP é¡¹ç›®æ•°æ®æµå’Œä½¿ç”¨æ–¹æ¡ˆ

## ä¸€ã€é¡¹ç›®æ¦‚è¿°

CFM FlowMP æ˜¯ä¸€ä¸ªåŸºäº**æ¡ä»¶æµåŒ¹é…ï¼ˆConditional Flow Matchingï¼‰**çš„è½¨è¿¹è§„åˆ’æ¡†æ¶ï¼Œä½œä¸ºä¸‰å±‚æ¶æ„çš„ä¸­é—´å±‚ï¼ˆL2ï¼‰ï¼Œè¿æ¥ä¸Šå±‚VLMï¼ˆL3ï¼‰è¯­ä¹‰ç†è§£å’Œä¸‹å±‚MPPIï¼ˆL1ï¼‰å±€éƒ¨ä¼˜åŒ–ã€‚

### ä¸‰å±‚æ¶æ„å®šä½

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  L3: Vision-Language Model (VLM)                            â”‚
â”‚  â””â”€ è¯­ä¹‰ç†è§£ã€åœºæ™¯è§£æã€ç”Ÿæˆè¯­ä¹‰ä»£ä»·åœ°å›¾                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚ cost_map [B,C,H,W]
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  L2: Safety-Embedded CFM (æœ¬é¡¹ç›®)                            â”‚
â”‚  â””â”€ æ¡ä»¶æµåŒ¹é…ç”Ÿæˆå¤šæ¨¡æ€è½¨è¿¹é”šç‚¹ (N=64 samples)                â”‚
â”‚     - è¾“å…¥: è¯­ä¹‰ä»£ä»·åœ°å›¾ + æœºå™¨äººçŠ¶æ€ + ç›®æ ‡ + æ§åˆ¶é£æ ¼æƒé‡      â”‚
â”‚     - è¾“å‡º: Næ¡å¸¦å®Œæ•´åŠ¨åŠ›å­¦çš„è½¨è¿¹ [p, v, a]                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚ trajectory_anchors [BÃ—N, T, 2]
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  L1: Model Predictive Path Integral (MPPI)                  â”‚
â”‚  â””â”€ ä½¿ç”¨è½¨è¿¹é”šç‚¹è¿›è¡Œå±€éƒ¨ä¼˜åŒ–å’Œå®æ—¶æ§åˆ¶                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### L2å±‚æ ¸å¿ƒç»„ä»¶

- **æ¨¡å‹æ¶æ„**ï¼šFlowMPTransformer / FlowMPUNet1D æ¡ä»¶å‘é‡åœºé¢„æµ‹
- **ä»£ä»·åœ°å›¾ç¼–ç å™¨**ï¼šCostMapEncoder å°†è¯­ä¹‰åœ°å›¾ç¼–ç ä¸ºæ½œåœ¨è¡¨ç¤º
- **è®­ç»ƒæ–¹æ³•**ï¼šFlow Matching æ’å€¼è·¯å¾„å’Œé€Ÿåº¦åœºå›å½’
- **æ¨ç†æ–¹æ³•**ï¼šRK4 ODE ç§¯åˆ†ä»å™ªå£°ç”Ÿæˆè½¨è¿¹
- **å¤šæ¨¡æ€ç”Ÿæˆ**ï¼šæ¯ä¸ªæ¡ä»¶ç”ŸæˆN=64æ¡å€™é€‰è½¨è¿¹ä¾›MPPIé€‰æ‹©
- **æ§åˆ¶é£æ ¼è°ƒèŠ‚**ï¼šæ”¯æŒ [w_safety, w_energy, w_smooth] æƒé‡åŠ¨æ€è°ƒæ•´è¡Œä¸º

---

### L2å±‚æ—¶é—´ç¼–ç å®ç°è¯¦è§£

#### æ—¶é—´ç¼–ç çš„ä½œç”¨

åœ¨æ¡ä»¶æµåŒ¹é…ï¼ˆCFMï¼‰æ¡†æ¶ä¸­ï¼Œæµæ—¶é—´ $t \in [0, 1]$ æ˜¯å…³é”®ä¿¡æ¯ï¼š
- $t=0$ï¼šåˆå§‹å™ªå£°çŠ¶æ€
- $t=1$ï¼šç›®æ ‡è½¨è¿¹
- $0<t<1$ï¼šæ’å€¼è·¯å¾„ä¸Šçš„ä¸­é—´çŠ¶æ€

æ—¶é—´ç¼–ç çš„ç›®çš„æ˜¯**å°†æ ‡é‡æ—¶é—´æ˜ å°„åˆ°é«˜ç»´ç‰¹å¾ç©ºé—´**ï¼Œä½¿æ¨¡å‹èƒ½å¤Ÿï¼š
1. æ„ŸçŸ¥å½“å‰ä½ç½®åœ¨å»å™ªè¿‡ç¨‹ä¸­çš„è¿›åº¦
2. æ ¹æ®æ—¶é—´åŠ¨æ€è°ƒæ•´é€Ÿåº¦åœºé¢„æµ‹
3. æ”¯æŒè‡ªé€‚åº”å±‚å½’ä¸€åŒ–ï¼ˆAdaLNï¼‰è¿›è¡Œæ¡ä»¶è°ƒåˆ¶

#### ä¸¤ç§æ—¶é—´ç¼–ç æ–¹å¼

##### **1. Fourier ç¼–ç ï¼ˆæ¨èï¼Œé»˜è®¤ä½¿ç”¨ï¼‰**

```
æ—¶é—´t âˆˆ [0, 1]
  â†“
éšæœºFourierç‰¹å¾æ˜ å°„
  â”œâ”€ é‡‡æ ·é¢‘ç‡: W ~ N(0, ÏƒÂ²) [embed_dim]
  â”œâ”€ æŠ•å½±: t_proj = t Â· W Â· 2Ï€
  â”‚        å½¢çŠ¶: [B, embed_dim]
  â”‚
  â”œâ”€ ä¸‰è§’å‡½æ•°: 
  â”‚  â”œâ”€ sin(t_proj): [B, embed_dim]
  â”‚  â””â”€ cos(t_proj): [B, embed_dim]
  â”‚
  â””â”€ æ‹¼æ¥+æŠ•å½±:
     embedding = Linear(
       concat([sin, cos]),
       output_dim = time_embed_dim
     )
     å½¢çŠ¶: [B, time_embed_dim]
```

**å®ç°ä»£ç **ï¼š
```python
class GaussianFourierProjection(nn.Module):
    def __init__(self, embed_dim=256, scale=30.0):
        super().__init__()
        self.embed_dim = embed_dim
        self.scale = scale
        
        # éšæœºé¢‘ç‡ï¼ˆæ³¨å†Œä¸ºbufferï¼Œä¸å‚ä¸æ¢¯åº¦è®¡ç®—ï¼‰
        W = torch.randn(embed_dim) * scale
        self.register_buffer('W', W)
        
        # è¾“å‡ºæŠ•å½±
        self.output_proj = nn.Linear(embed_dim * 2, embed_dim)
    
    def forward(self, t: torch.Tensor) -> torch.Tensor:
        """
        Args:
            t: [B] æˆ– [B, 1]ï¼Œå€¼åœ¨ [0, 1]
        Returns:
            [B, embed_dim]
        """
        if t.dim() == 1:
            t = t.unsqueeze(-1)  # [B] â†’ [B, 1]
        
        # æ˜ å°„åˆ°Fourierç©ºé—´
        t_proj = t * self.W[None, :] * 2 * math.pi  # [B, embed_dim]
        
        # ä¸‰è§’å‡½æ•°ç‰¹å¾
        embedding = torch.cat([
            torch.sin(t_proj),  # [B, embed_dim]
            torch.cos(t_proj),  # [B, embed_dim]
        ], dim=-1)  # [B, embed_dim*2]
        
        # æŠ•å½±å›desiredç»´åº¦
        return self.output_proj(embedding)  # [B, embed_dim]
```

**ä¼˜åŠ¿**ï¼š
- âœ“ æ•æ‰é«˜é¢‘æ—¶é—´å˜åŒ–
- âœ“ å‚æ•°é«˜æ•ˆï¼ˆåªéœ€random frequenciesï¼‰
- âœ“ æ³›åŒ–èƒ½åŠ›å¼º

##### **2. æ­£å¼¦æ³¢ä½ç½®ç¼–ç **

```
æ—¶é—´t âˆˆ [0, 1]
  â†“
ç¼©æ”¾: t' = t Â· 1000
  â†“
é¢‘ç‡å¸¦ç”Ÿæˆ
  â”œâ”€ k = 0, 1, ..., embed_dim/2
  â”œâ”€ freq_k = 10000^(-2k/embed_dim)
  â””â”€ å½¢çŠ¶: [embed_dim/2]
  â†“
ä¸‰è§’ç¼–ç :
  â”œâ”€ cos(t' Â· freq_k): [B, embed_dim/2]
  â””â”€ sin(t' Â· freq_k): [B, embed_dim/2]
  â†“
æ‹¼æ¥+æŠ•å½± â†’ [B, embed_dim]
```

**å®ç°ä»£ç **ï¼š
```python
class SinusoidalPositionalEncoding(nn.Module):
    def __init__(self, embed_dim=256, max_period=10000.0):
        super().__init__()
        self.embed_dim = embed_dim
        self.max_period = max_period
        
        # é¢„è®¡ç®—é¢‘ç‡
        half_dim = embed_dim // 2
        freqs = torch.exp(
            -math.log(max_period) * 
            torch.arange(half_dim, dtype=torch.float32) / half_dim
        )
        self.register_buffer('freqs', freqs)
        
        self.output_proj = nn.Linear(embed_dim, embed_dim)
    
    def forward(self, t: torch.Tensor) -> torch.Tensor:
        """
        Args:
            t: [B] æˆ– [B, 1]
        Returns:
            [B, embed_dim]
        """
        if t.dim() == 1:
            t = t.unsqueeze(-1)  # [B, 1]
        
        # ç¼©æ”¾æ—¶é—´åˆ°æ›´å¤§èŒƒå›´ä»¥è·å¾—æ›´å¥½çš„é¢‘ç‡è¦†ç›–
        t = t * 1000.0  # [B, 1]
        
        # è®¡ç®—ä¸‰è§’å‡½æ•°ç‰¹å¾
        args = t * self.freqs[None, :]  # [B, half_dim]
        embedding = torch.cat([
            torch.cos(args),  # [B, half_dim]
            torch.sin(args),  # [B, half_dim]
        ], dim=-1)  # [B, embed_dim]
        
        return self.output_proj(embedding)
```

#### L2å±‚ä¸­çš„æ—¶é—´ç¼–ç é›†æˆ

```
è¾“å…¥å±‚ï¼šODEæ±‚è§£è¿‡ç¨‹ä¸­çš„æµæ—¶é—´
  â”‚
  â”œâ”€ t ~ [0, 0.05, 0.10, ..., 0.95, 1.00] (å‡åŒ€è°ƒåº¦)
  â”‚  æˆ–
  â”œâ”€ t ~ [0.0, 0.8, 0.85, 0.9, 0.92, 0.94, 0.96, 0.98, 1.0] (éå‡åŒ€)
  â”‚
  â†“
ã€æ—¶é—´ç¼–ç å™¨ã€‘(GaussianFourier or Sinusoidal)
  â”‚
  â”œâ”€ è¾“å…¥: t [B]
  â”œâ”€ å¤„ç†:
  â”‚  â”œâ”€ Fourier/Sinusoidalæ˜ å°„
  â”‚  â”œâ”€ è¾“å‡º: time_emb [B, 256]
  â”‚  â””â”€ åŒ…å«é«˜é¢‘å’Œä½é¢‘æ—¶é—´ä¿¡æ¯
  â”‚
  â†“
ã€æ¡ä»¶èåˆã€‘
  â”‚
  â”œâ”€ æ¥è‡ªL3çš„ä»£ä»·åœ°å›¾: e_map [B, 256]
  â”œâ”€ å½“å‰æœºå™¨äººçŠ¶æ€: x_curr [B, 6]
  â”œâ”€ ç›®æ ‡çŠ¶æ€: x_goal [B, 4]
  â”œâ”€ æ§åˆ¶é£æ ¼: w_style [B, 3]
  â”‚
  â”œâ”€ time_embä¹Ÿä½œä¸ºæ¡ä»¶çš„ä¸€éƒ¨åˆ†å‚ä¸èåˆ
  â”‚
  â†“
ã€ç»Ÿä¸€æ¡ä»¶å‘é‡ã€‘: condition [B, hidden_dim]
  â”‚
  â†“
ã€é€‚åº”å±‚å½’ä¸€åŒ– (AdaLN)ã€‘
  â”‚
  â””â”€ ä½¿ç”¨time_embè°ƒåˆ¶Transformer/U-Netçš„æ¯ä¸€å±‚
```

#### Transformerä¸­çš„æ—¶é—´ç¼–ç ä½¿ç”¨æµç¨‹

```python
# åœ¨FlowMPTransformer.forward()ä¸­

# 1ï¸âƒ£ æ—¶é—´ç¼–ç 
time_emb = self.time_embed(t)  # [B] â†’ [B, 256]

# 2ï¸âƒ£ æ¡ä»¶ç¼–ç ï¼ˆåŒ…æ‹¬start/goalä½ç½®ï¼‰
cond_emb = self.cond_encoder(
    start_pos=start_pos,
    goal_pos=goal_pos,
    start_vel=start_vel,
    goal_vel=goal_vel,
    env_encoding=env_encoding,
)  # [B, 256]

# 3ï¸âƒ£ èåˆæ—¶é—´å’Œæ¡ä»¶ä¿¡æ¯
if self.condition_type == "token":
    # æ–¹å¼Aï¼šå°†time_embå’Œcond_embä½œä¸ºç‰¹æ®Štokenå‰ç½®
    time_token = self.cond_token_proj(time_emb)      # [B, hidden_dim]
    cond_token = self.cond_token_proj(cond_emb)      # [B, hidden_dim]
    
    prefix_tokens = torch.stack([time_token, cond_token], dim=1)  # [B, 2, hidden_dim]
    h = torch.cat([prefix_tokens, h], dim=1)  # [B, T+2, hidden_dim]

else:  # condition_type == "adaLN"
    # æ–¹å¼Bï¼šé€šè¿‡AdaLNè°ƒåˆ¶æ¯ä¸€å±‚
    combined_cond = self.cond_combine(
        torch.cat([time_emb, cond_emb], dim=-1)
    )  # [B, hidden_dim]
    
    # åœ¨Transformerå—ä¸­ä½¿ç”¨
    # å¯¹äºæ¯ä¸€å±‚:
    #   x_norm = AdaLN(x, combined_cond)
    #   ...

# 4ï¸âƒ£ Transformerç¼–ç 
for i, block in enumerate(self.transformer_blocks):
    h = block(
        h,
        cond_embed=combined_cond,  # ä¼ å…¥æ¡ä»¶
        cross_attention_input=cross_attn_input,
    )
    # æ¯ä¸€å±‚éƒ½ä½¿ç”¨time_embæä¾›çš„æ—¶é—´ä¿¡æ¯

# 5ï¸âƒ£ è¾“å‡ºé¢„æµ‹å‘é‡åœº
output = self.output_head(h)  # [B, T, 6]
```

#### å…³é”®å‚æ•°é…ç½®

```python
from cfm_flowmp.models import create_l2_safety_cfm

# æ—¶é—´ç¼–ç é…ç½®ç¤ºä¾‹

# æ–¹æ¡ˆ1ï¼šFourierç¼–ç ï¼ˆæ¨èï¼‰
config1 = L2Config(
    model_type="transformer",
    hidden_dim=256,
    num_layers=8,
    num_heads=8,
    # Transformerä¼šè‡ªåŠ¨åˆ›å»ºGaussianFourierProjection
    # å‚æ•°åœ¨transformer.pyä¸­é…ç½®
)

# æŸ¥çœ‹Transformeråˆå§‹åŒ–ä¸­çš„æ—¶é—´ç¼–ç å‚æ•°
model = FlowMPTransformer(
    state_dim=2,
    hidden_dim=256,
    time_embed_type="fourier",  # æˆ– "sinusoidal"
    time_embed_dim=256,         # FourieræŠ•å½±çš„è¾“å‡ºç»´åº¦
    embed_dim=256,              # åŸå§‹Fourierç‰¹å¾ç»´åº¦
    scale=30.0,                 # é«˜æ–¯éšæœºé¢‘ç‡çš„æ ‡å‡†å·®
)
```

#### æ—¶é—´ç¼–ç çš„æ•ˆæœéªŒè¯

```python
# å¯è§†åŒ–æ—¶é—´ç¼–ç 

import torch
import matplotlib.pyplot as plt
from cfm_flowmp.models.embeddings import GaussianFourierProjection

# åˆ›å»ºç¼–ç å™¨
encoder = GaussianFourierProjection(embed_dim=256, scale=30.0)

# ç”Ÿæˆæ—¶é—´ç‚¹
t_values = torch.linspace(0, 1, 100).unsqueeze(-1)  # [100, 1]

# ç¼–ç 
embeddings = encoder(t_values)  # [100, 256]

# å¯è§†åŒ–ï¼šè§‚å¯Ÿéšæ—¶é—´å˜åŒ–çš„ç‰¹å¾å“åº”
plt.figure(figsize=(12, 6))

# ç»˜åˆ¶ä¸åŒç‰¹å¾åœ¨æ—¶é—´ä¸Šçš„å“åº”
for i in [0, 50, 100, 150, 200]:
    plt.plot(t_values.numpy(), embeddings[:, i].numpy(), 
             label=f'Feature {i}')

plt.xlabel('Flow Time (t)')
plt.ylabel('Embedding Value')
plt.title('Gaussian Fourier Projection Response over Time')
plt.legend()
plt.grid(True)
plt.show()

# ç»“æœï¼šçœ‹åˆ°ä¸åŒç‰¹å¾ä»¥ä¸åŒé¢‘ç‡å“åº”æ—¶é—´å˜åŒ–
# - ä½é¢‘ç‰¹å¾ï¼šç¼“æ…¢å˜åŒ–ï¼Œå…¨å±€æ—¶é—´è¿›åº¦
# - é«˜é¢‘ç‰¹å¾ï¼šå¿«é€ŸæŒ¯è¡ï¼Œç»†ç²’åº¦æ—¶é—´ä¿¡æ¯
```

---

## äºŒã€æ•°æ®æµè¯¦è§£

### 2.0 L2å±‚æ—¶é—´ç¼–ç ç³»ç»Ÿ

### 2.1 è®­ç»ƒé˜¶æ®µæ•°æ®æµ

#### å®Œæ•´æµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     è®­ç»ƒæ•°æ®æµ (Training Flow)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. æ•°æ®åŠ è½½ä¸é¢„å¤„ç† (Data Loading & Preprocessing)
   â”‚
   â”œâ”€ TrajectoryDataset / SyntheticTrajectoryDataset
   â”‚  â”œâ”€ è¾“å…¥: è½¨è¿¹æ•°æ®æ–‡ä»¶ (.npz, .npy, .h5, .pkl) æˆ–åˆæˆè½¨è¿¹
   â”‚  â”‚
   â”‚  â”œâ”€ æ•°æ®ç»´åº¦:
   â”‚  â”‚  â”œâ”€ åŸå§‹æ•°æ®: positions [N, T, D]
   â”‚  â”‚  â”‚            where: N=è½¨è¿¹æ•°é‡, T=æ—¶é—´æ­¥æ•°, D=çŠ¶æ€ç»´åº¦
   â”‚  â”‚  â”œâ”€ å¯é€‰é¡¹: velocities [N, T, D]
   â”‚  â”‚  â””â”€ å¯é€‰é¡¹: accelerations [N, T, D]
   â”‚  â”‚
   â”‚  â”œâ”€ é¢„å¤„ç†æ­¥éª¤:
   â”‚  â”‚  â”œâ”€ â‘  è®¡ç®—å¯¼æ•° (å¦‚æœæœªæä¾›)
   â”‚  â”‚  â”‚   â””â”€ velocity = Î”position / Î”time (ä¸­å¿ƒå·®åˆ†)
   â”‚  â”‚  â”‚   â””â”€ acceleration = Î”velocity / Î”time
   â”‚  â”‚  â”‚
   â”‚  â”‚  â”œâ”€ â‘¡ æ•°æ®å½’ä¸€åŒ– (å¯é€‰)
   â”‚  â”‚  â”‚   â”œâ”€ è®¡ç®—ç»Ÿè®¡é‡: mean_pos, std_pos, mean_vel, std_vel
   â”‚  â”‚  â”‚   â””â”€ å½’ä¸€åŒ–: (data - mean) / std
   â”‚  â”‚  â”‚
   â”‚  â”‚  â””â”€ â‘¢ æå–æ¡ä»¶ä¿¡æ¯
   â”‚  â”‚      â”œâ”€ start_pos: è½¨è¿¹ç¬¬ä¸€ä¸ªæ—¶é—´æ­¥çš„ä½ç½® [T, D] â†’ [D]
   â”‚  â”‚      â”œâ”€ goal_pos: è½¨è¿¹æœ€åä¸€ä¸ªæ—¶é—´æ­¥çš„ä½ç½® [T, D] â†’ [D]
   â”‚  â”‚      â””â”€ start_vel: è½¨è¿¹ç¬¬ä¸€ä¸ªæ—¶é—´æ­¥çš„é€Ÿåº¦ [T, D] â†’ [D]
   â”‚  â”‚
   â”‚  â””â”€ è¾“å‡ºæ ¼å¼ (æ¯ä¸ªæ ·æœ¬):
   â”‚     â”œâ”€ positions: [T, D]
   â”‚     â”œâ”€ velocities: [T, D]
   â”‚     â”œâ”€ accelerations: [T, D]
   â”‚     â”œâ”€ start_pos: [D]
   â”‚     â”œâ”€ goal_pos: [D]
   â”‚     â””â”€ start_vel: [D]
   â”‚
   â””â”€ DataLoader: ç»„ç»‡æˆæ‰¹æ¬¡
      â”œâ”€ batch_size: B (é€šå¸¸ 32-128)
      â”œâ”€ è¾“å‡ºå¼ é‡å½¢çŠ¶:
      â”‚  â”œâ”€ positions_batch: [B, T, D]
      â”‚  â”œâ”€ velocities_batch: [B, T, D]
      â”‚  â”œâ”€ accelerations_batch: [B, T, D]
      â”‚  â”œâ”€ start_pos_batch: [B, D]
      â”‚  â”œâ”€ goal_pos_batch: [B, D]
      â”‚  â””â”€ start_vel_batch: [B, D]
      â”‚
      â””â”€ DataLoader ç‰¹æ€§:
         â”œâ”€ shuffle=True (éšæœºé¡ºåºè®­ç»ƒ)
         â”œâ”€ drop_last=True (ä¸¢å¼ƒæœ€åä¸å®Œæ•´æ‰¹æ¬¡)
         â””â”€ num_workers (å¤šè¿›ç¨‹æ•°æ®åŠ è½½)

2. Flow Matching æ’å€¼ä¸ç›®æ ‡è®¡ç®— (Flow Interpolation)
   â”‚
   â”œâ”€ FlowInterpolator.interpolate_trajectory()
   â”‚  â”‚
   â”‚  â”œâ”€ ã€ç¬¬ä¸€æ­¥ã€‘é‡‡æ ·æµæ—¶é—´
   â”‚  â”‚   â””â”€ t ~ Uniform(0, 1) â†’ [B] (æ¯ä¸ªæ ·æœ¬ä¸€ä¸ªæ—¶é—´å€¼)
   â”‚  â”‚   â””â”€ æ„ä¹‰: åœ¨æ’å€¼è·¯å¾„ä¸Šçš„ä½ç½®
   â”‚  â”‚
   â”‚  â”œâ”€ ã€ç¬¬äºŒæ­¥ã€‘é‡‡æ ·é«˜æ–¯å™ªå£°
   â”‚  â”‚   â”œâ”€ Îµ_q ~ N(0, I) â†’ [B, T, D] (ä½ç½®å™ªå£°)
   â”‚  â”‚   â”œâ”€ Îµ_q_dot ~ N(0, I) â†’ [B, T, D] (é€Ÿåº¦å™ªå£°)
   â”‚  â”‚   â””â”€ Îµ_q_ddot ~ N(0, I) â†’ [B, T, D] (åŠ é€Ÿåº¦å™ªå£°)
   â”‚  â”‚
   â”‚  â”œâ”€ ã€ç¬¬ä¸‰æ­¥ã€‘çº¿æ€§æ’å€¼çŠ¶æ€ï¼ˆä»å™ªå£°åˆ°ä¸“å®¶è½¨è¿¹ï¼‰
   â”‚  â”‚   â”‚
   â”‚  â”‚   â”œâ”€ ä½ç½®æ’å€¼:
   â”‚  â”‚   â”‚  q_t = t * q_1 + (1-t) * Îµ_q
   â”‚  â”‚   â”‚  å½¢çŠ¶: [B, T, D]
   â”‚  â”‚   â”‚  å«ä¹‰: t=0æ—¶ä¸ºçº¯å™ªå£°ï¼Œt=1æ—¶ä¸ºä¸“å®¶è½¨è¿¹
   â”‚  â”‚   â”‚
   â”‚  â”‚   â”œâ”€ é€Ÿåº¦æ’å€¼:
   â”‚  â”‚   â”‚  q_dot_t = t * q_dot_1 + (1-t) * Îµ_q_dot
   â”‚  â”‚   â”‚  å½¢çŠ¶: [B, T, D]
   â”‚  â”‚   â”‚
   â”‚  â”‚   â””â”€ åŠ é€Ÿåº¦æ’å€¼:
   â”‚  â”‚      q_ddot_t = t * q_ddot_1 + (1-t) * Îµ_q_ddot
   â”‚  â”‚      å½¢çŠ¶: [B, T, D]
   â”‚  â”‚
   â”‚  â”œâ”€ ã€ç¬¬å››æ­¥ã€‘åˆå¹¶æ’å€¼çŠ¶æ€
   â”‚  â”‚   â””â”€ x_t = concat([q_t, q_dot_t, q_ddot_t])
   â”‚  â”‚   â””â”€ å½¢çŠ¶: [B, T, 6] (å¯¹äº D=2 çš„çŠ¶æ€)
   â”‚  â”‚
   â”‚  â””â”€ ã€ç¬¬äº”æ­¥ã€‘è®¡ç®—ç›®æ ‡å‘é‡åœº
   â”‚     â”‚
   â”‚     â”œâ”€ å‘é‡åœºçš„å®šä¹‰ï¼šé€Ÿåº¦åœº u æè¿°äº†ä»å™ªå£°æµå‘ä¸“å®¶è½¨è¿¹çš„æ–¹å‘
   â”‚     â”‚
   â”‚     â”œâ”€ ä½ç½®é€Ÿåº¦åœº (Velocity Field):
   â”‚     â”‚  u_target = (q_1 - q_t) / (1-t)
   â”‚     â”‚  å½¢çŠ¶: [B, T, D]
   â”‚     â”‚  å«ä¹‰: å®ç°ä½ç½®ä» q_t åˆ° q_1 çš„å˜åŒ–é€Ÿåº¦
   â”‚     â”‚  æ³¨æ„: åˆ†æ¯ (1-t) æ˜¯ä¸ºäº†åœ¨ tâ†’1 æ—¶å½’ä¸€åŒ–
   â”‚     â”‚
   â”‚     â”œâ”€ é€Ÿåº¦åŠ é€Ÿåº¦åœº (Acceleration Field):
   â”‚     â”‚  v_target = (q_dot_1 - q_dot_t) / (1-t)
   â”‚     â”‚  å½¢çŠ¶: [B, T, D]
   â”‚     â”‚  å«ä¹‰: å®ç°é€Ÿåº¦ä» q_dot_t åˆ° q_dot_1 çš„å˜åŒ–é€Ÿåº¦
   â”‚     â”‚
   â”‚     â””â”€ åŠ é€Ÿåº¦æ€¥åŠ¨åœº (Jerk Field):
   â”‚        w_target = (q_ddot_1 - q_ddot_t) / (1-t)
   â”‚        å½¢çŠ¶: [B, T, D]
   â”‚        å«ä¹‰: å®ç°åŠ é€Ÿåº¦ä» q_ddot_t åˆ° q_ddot_1 çš„å˜åŒ–é€Ÿåº¦
   â”‚
   â””â”€ è¾“å‡ºå¼ é‡:
      â”œâ”€ x_t: [B, T, 6] æ’å€¼çŠ¶æ€
      â”œâ”€ t: [B] æµæ—¶é—´
      â”œâ”€ u_target: [B, T, D] ä½ç½®é€Ÿåº¦åœºç›®æ ‡
      â”œâ”€ v_target: [B, T, D] åŠ é€Ÿåº¦åœºç›®æ ‡
      â””â”€ w_target: [B, T, D] æ€¥åŠ¨åœºç›®æ ‡

3. æ¨¡å‹å‰å‘ä¼ æ’­ (Model Forward Pass)
   â”‚
   â”œâ”€ è¾“å…¥å‡†å¤‡:
   â”‚  â”œâ”€ x_t: [B, T, 6]
   â”‚  â”œâ”€ t: [B]
   â”‚  â”œâ”€ start_pos: [B, D]
   â”‚  â”œâ”€ goal_pos: [B, D]
   â”‚  â””â”€ start_vel: [B, D]
   â”‚
   â”œâ”€ FlowMPTransformer å†…éƒ¨æµç¨‹:
   â”‚  â”‚
   â”‚  â”œâ”€ ã€ç¬¬ä¸€æ­¥ã€‘è¾“å…¥æŠ•å½±ä¸åµŒå…¥
   â”‚  â”‚   â”‚
   â”‚  â”‚   â”œâ”€ è¾“å…¥çº¿æ€§æ˜ å°„:
   â”‚  â”‚   â”‚  x_t: [B, T, 6] â†’ [B, T, hidden_dim]
   â”‚  â”‚   â”‚  â””â”€ Linear(6, hidden_dim)
   â”‚  â”‚   â”‚
   â”‚  â”‚   â”œâ”€ ä½ç½®ç¼–ç  (Positional Encoding):
   â”‚  â”‚   â”‚  â””â”€ PE(pos) = [sin(pos/10000^(2i/d)), cos(...)]
   â”‚  â”‚   â”‚  â””â”€ æ·»åŠ åˆ°æ¯ä¸ªæ—¶é—´æ­¥: x' = x + PE(t)
   â”‚  â”‚   â”‚
   â”‚  â”‚   â””â”€ è¾“å‡º: [B, T, hidden_dim]
   â”‚  â”‚
   â”‚  â”œâ”€ ã€ç¬¬äºŒæ­¥ã€‘æ—¶é—´åµŒå…¥
   â”‚  â”‚   â”‚
   â”‚  â”‚   â”œâ”€ Gaussian Fourier Projection:
   â”‚  â”‚   â”‚  â”œâ”€ sin(2Ï€*t*b_k) for k in range(num_fourier)
   â”‚  â”‚   â”‚  â”œâ”€ cos(2Ï€*t*b_k) for k in range(num_fourier)
   â”‚  â”‚   â”‚  â””â”€ å…¶ä¸­ b_k ~ N(0, ÏƒÂ²)
   â”‚  â”‚   â”‚
   â”‚  â”‚   â””â”€ è¾“å‡º: time_emb [B, cond_dim]
   â”‚  â”‚
   â”‚  â”œâ”€ ã€ç¬¬ä¸‰æ­¥ã€‘æ¡ä»¶ç¼–ç 
   â”‚  â”‚   â”‚
   â”‚  â”‚   â”œâ”€ ConditionEncoder å¤„ç†:
   â”‚  â”‚   â”‚  â”œâ”€ concat([start_pos, goal_pos, start_vel]) â†’ [B, 5*D]
   â”‚  â”‚   â”‚  â”œâ”€ Linear(5*D, hidden_dim)
   â”‚  â”‚   â”‚  â””â”€ è¾“å‡º: cond_emb [B, cond_dim]
   â”‚  â”‚   â”‚
   â”‚  â”‚   â””â”€ æ³¨æ„ï¼šstart_vel åœ¨ç›®æ ‡ä½ç½®æ—¶ä¸º [0, 0]
   â”‚  â”‚
   â”‚  â”œâ”€ ã€ç¬¬å››æ­¥ã€‘æ¡ä»¶èåˆ
   â”‚  â”‚   â”‚
   â”‚  â”‚   â”œâ”€ æ–¹æ³•ï¼šåŠ æ³•èåˆæˆ–è¿æ¥åæ˜ å°„
   â”‚  â”‚   â”‚  â””â”€ combined_cond = time_emb + cond_emb
   â”‚  â”‚   â”‚  â””â”€ å½¢çŠ¶: [B, hidden_dim]
   â”‚  â”‚   â”‚
   â”‚  â”‚   â””â”€ ä½œç”¨ï¼šç”¨äº AdaLN çš„å‚æ•°ç”Ÿæˆ
   â”‚  â”‚
   â”‚  â”œâ”€ ã€ç¬¬äº”æ­¥ã€‘Transformer ç¼–ç å™¨ (L å±‚)
   â”‚  â”‚   â”‚
   â”‚  â”‚   â””â”€ å¯¹æ¯ä¸€å±‚:
   â”‚  â”‚      â”‚
   â”‚  â”‚      â”œâ”€ [A] AdaLN (Adaptive Layer Normalization):
   â”‚  â”‚      â”‚   â”‚
   â”‚  â”‚      â”‚   â”œâ”€ è®¡ç®— scale Î³ å’Œ shift Î²:
   â”‚  â”‚      â”‚   â”‚  Î³ = Linear_scale(combined_cond)  [B, hidden_dim]
   â”‚  â”‚      â”‚   â”‚  Î² = Linear_shift(combined_cond)  [B, hidden_dim]
   â”‚  â”‚      â”‚   â”‚
   â”‚  â”‚      â”‚   â”œâ”€ å¯¹æ‰€æœ‰åºåˆ—ä½ç½®åº”ç”¨:
   â”‚  â”‚      â”‚   â”‚  LN_out = (x - Î¼) / Ïƒ
   â”‚  â”‚      â”‚   â”‚  AdaLN_out = Î³ * LN_out + Î²
   â”‚  â”‚      â”‚   â”‚
   â”‚  â”‚      â”‚   â””â”€ è¾“å‡º: [B, T, hidden_dim]
   â”‚  â”‚      â”‚
   â”‚  â”‚      â”œâ”€ [B] å¤šå¤´è‡ªæ³¨æ„åŠ› (Multi-Head Self-Attention):
   â”‚  â”‚      â”‚   â”‚
   â”‚  â”‚      â”‚   â”œâ”€ çº¿æ€§æ˜ å°„ç”Ÿæˆ Q, K, V:
   â”‚  â”‚      â”‚   â”‚  Q = Linear_q(x)  [B, T, hidden_dim]
   â”‚  â”‚      â”‚   â”‚  K = Linear_k(x)  [B, T, hidden_dim]
   â”‚  â”‚      â”‚   â”‚  V = Linear_v(x)  [B, T, hidden_dim]
   â”‚  â”‚      â”‚   â”‚
   â”‚  â”‚      â”‚   â”œâ”€ åˆ†å¤´ä¸ç¼©æ”¾ç‚¹ç§¯æ³¨æ„åŠ›:
   â”‚  â”‚      â”‚   â”‚  åˆ†å¤´: Q,K,V åˆ†åˆ«åˆ†æˆ num_heads ä»½
   â”‚  â”‚      â”‚   â”‚  attention = softmax(Q@K^T / âˆšd_k) @ V
   â”‚  â”‚      â”‚   â”‚
   â”‚  â”‚      â”‚   â”œâ”€ åˆå¹¶å¤šå¤´:
   â”‚  â”‚      â”‚   â”‚  output = Linear_out(concat(heads))
   â”‚  â”‚      â”‚   â”‚
   â”‚  â”‚      â”‚   â”œâ”€ æ®‹å·®è¿æ¥:
   â”‚  â”‚      â”‚   â”‚  out = x + attention_out
   â”‚  â”‚      â”‚   â”‚
   â”‚  â”‚      â”‚   â””â”€ è¾“å‡º: [B, T, hidden_dim]
   â”‚  â”‚      â”‚
   â”‚  â”‚      â”œâ”€ [C] AdaLN (ç¬¬äºŒæ¬¡):
   â”‚  â”‚      â”‚   â””â”€ åŒä¸Šï¼Œä½¿ç”¨ç›¸åŒçš„ Î³ å’Œ Î²
   â”‚  â”‚      â”‚   â””â”€ è¾“å‡º: [B, T, hidden_dim]
   â”‚  â”‚      â”‚
   â”‚  â”‚      â””â”€ [D] å‰é¦ˆç½‘ç»œ (Feed-Forward Network):
   â”‚  â”‚          â”‚
   â”‚  â”‚          â”œâ”€ ç»“æ„: Linear(d) â†’ ReLU â†’ Linear(4d) â†’ ReLU â†’ Linear(d)
   â”‚  â”‚          â”‚  (æˆ– GELU ä½œä¸ºæ¿€æ´»å‡½æ•°)
   â”‚  â”‚          â”‚
   â”‚  â”‚          â”œâ”€ è®¡ç®—è¿‡ç¨‹:
   â”‚  â”‚          â”‚  ffn_out = Linear_2(ReLU(Linear_1(x)))
   â”‚  â”‚          â”‚
   â”‚  â”‚          â”œâ”€ æ®‹å·®è¿æ¥:
   â”‚  â”‚          â”‚  out = x + ffn_out
   â”‚  â”‚          â”‚
   â”‚  â”‚          â””â”€ è¾“å‡º: [B, T, hidden_dim]
   â”‚  â”‚
   â”‚  â”œâ”€ ã€ç¬¬å…­æ­¥ã€‘æœ€åä¸€å±‚ AdaLN
   â”‚  â”‚   â””â”€ å¯¹æ•´ä¸ªåºåˆ—åº”ç”¨æœ€åçš„è‡ªé€‚åº”å½’ä¸€åŒ–
   â”‚  â”‚   â””â”€ è¾“å‡º: [B, T, hidden_dim]
   â”‚  â”‚
   â”‚  â””â”€ ã€ç¬¬ä¸ƒæ­¥ã€‘è¾“å‡ºå¤´
   â”‚      â”‚
   â”‚      â”œâ”€ è¾“å‡ºæ˜ å°„:
   â”‚      â”‚  output = Linear(hidden_dim, 6)  # æ˜ å°„åˆ° 3 ä¸ªå‘é‡åœº
   â”‚      â”‚
   â”‚      â”œâ”€ åˆ†è§£:
   â”‚      â”‚  u_pred = output[..., :D]  # ä½ç½®é€Ÿåº¦åœº [B, T, D]
   â”‚      â”‚  v_pred = output[..., D:2*D]  # åŠ é€Ÿåº¦åœº [B, T, D]
   â”‚      â”‚  w_pred = output[..., 2*D:3*D]  # æ€¥åŠ¨åœº [B, T, D]
   â”‚      â”‚
   â”‚      â””â”€ è¾“å‡º: [B, T, 6]
   â”‚
   â””â”€ æ¨¡å‹è¾“å‡º:
      â”œâ”€ u_pred: [B, T, D] é¢„æµ‹çš„ä½ç½®é€Ÿåº¦åœº
      â”œâ”€ v_pred: [B, T, D] é¢„æµ‹çš„åŠ é€Ÿåº¦åœº
      â””â”€ w_pred: [B, T, D] é¢„æµ‹çš„æ€¥åŠ¨åœº

4. æŸå¤±è®¡ç®—ä¸åå‘ä¼ æ’­ (Loss & Optimization)
   â”‚
   â”œâ”€ æŸå¤±å‡½æ•°è®¡ç®—:
   â”‚  â”‚
   â”‚  â”œâ”€ ä½ç½®é€Ÿåº¦åœºæŸå¤±:
   â”‚  â”‚  L_u = MSE(u_pred, u_target)
   â”‚  â”‚      = (1/(B*T*D)) * sum((u_pred - u_target)Â²)
   â”‚  â”‚
   â”‚  â”œâ”€ åŠ é€Ÿåº¦åœºæŸå¤±:
   â”‚  â”‚  L_v = MSE(v_pred, v_target)
   â”‚  â”‚      = (1/(B*T*D)) * sum((v_pred - v_target)Â²)
   â”‚  â”‚
   â”‚  â”œâ”€ æ€¥åŠ¨åœºæŸå¤±:
   â”‚  â”‚  L_w = MSE(w_pred, w_target)
   â”‚  â”‚      = (1/(B*T*D)) * sum((w_pred - w_target)Â²)
   â”‚  â”‚
   â”‚  â””â”€ åŠ æƒæ€»æŸå¤±:
   â”‚     L_total = Î»_u * L_u + Î»_v * L_v + Î»_w * L_w
   â”‚     (é»˜è®¤: Î»_u = Î»_v = Î»_w = 1.0)
   â”‚
   â”œâ”€ åå‘ä¼ æ’­:
   â”‚  â”‚
   â”‚  â”œâ”€ è®¡ç®—æ¢¯åº¦: âˆ‡L w.r.t. æ‰€æœ‰å‚æ•°
   â”‚  â”‚
   â”‚  â”œâ”€ æ¢¯åº¦è£å‰ª (å¯é€‰):
   â”‚  â”‚  â””â”€ é˜²æ­¢æ¢¯åº¦çˆ†ç‚¸: norm(âˆ‡) â†’ min(norm(âˆ‡), clip_value)
   â”‚  â”‚
   â”‚  â””â”€ æ¢¯åº¦ç´¯ç§¯ (å¯é€‰):
   â”‚     â””â”€ å¤šä¸ªæ‰¹æ¬¡çš„æ¢¯åº¦ç›¸åŠ ï¼Œç„¶åä¸€èµ·ä¼˜åŒ–
   â”‚
   â””â”€ ä¼˜åŒ–å™¨æ›´æ–°:
      â”‚
      â”œâ”€ Adam ä¼˜åŒ–å™¨:
      â”‚  â”œâ”€ m_t = Î²1 * m_{t-1} + (1-Î²1) * âˆ‡L  (ä¸€é˜¶çŸ©)
      â”‚  â”œâ”€ v_t = Î²2 * v_{t-1} + (1-Î²2) * (âˆ‡L)Â²  (äºŒé˜¶çŸ©)
      â”‚  â”œâ”€ mÌ‚_t = m_t / (1-Î²1^t)  (åå·®ä¿®æ­£)
      â”‚  â”œâ”€ vÌ‚_t = v_t / (1-Î²2^t)
      â”‚  â””â”€ Î¸_{t+1} = Î¸_t - lr * mÌ‚_t / (âˆšvÌ‚_t + Îµ)
      â”‚
      â”œâ”€ å­¦ä¹ ç‡è°ƒåº¦ (å¯é€‰):
      â”‚  â””â”€ Warmup + Cosine Decay
      â”‚     lr(step) = base_lr * min(step/warmup_steps, cos_decay(step))
      â”‚
      â””â”€ å‚æ•°æ›´æ–°å®Œæˆ
         â””â”€ ç»§ç»­ä¸‹ä¸€æ‰¹æ¬¡è®­ç»ƒ
```

#### æ•°æ®ç»´åº¦è¿½è¸ªç¤ºä¾‹

```python
# å‡è®¾å‚æ•°: B=32, T=64, D=2, hidden_dim=256

# æ‰¹æ¬¡æ•°æ®
positions: torch.Size([32, 64, 2])
velocities: torch.Size([32, 64, 2])
accelerations: torch.Size([32, 64, 2])

# Flow Matching é˜¶æ®µ
t: torch.Size([32])  # æµæ—¶é—´
x_t: torch.Size([32, 64, 6])  # æ‹¼æ¥: [pos, vel, acc]

# ç›®æ ‡åœº
u_target: torch.Size([32, 64, 2])  # ä½ç½®é€Ÿåº¦åœº
v_target: torch.Size([32, 64, 2])  # åŠ é€Ÿåº¦åœº
w_target: torch.Size([32, 64, 2])  # æ€¥åŠ¨åœº

# åµŒå…¥
time_emb: torch.Size([32, 256])  # æ—¶é—´åµŒå…¥
cond_emb: torch.Size([32, 256])  # æ¡ä»¶åµŒå…¥

# æ¨¡å‹ä¸­é—´
x_embed: torch.Size([32, 64, 256])  # è¾“å…¥æŠ•å½±
x_pos_enc: torch.Size([32, 64, 256])  # åŠ å…¥ä½ç½®ç¼–ç 
x_attn: torch.Size([32, 64, 256])  # æ³¨æ„åŠ›è¾“å‡º
x_ffn: torch.Size([32, 64, 256])  # å‰é¦ˆè¾“å‡º

# æ¨¡å‹è¾“å‡º
u_pred: torch.Size([32, 64, 2])
v_pred: torch.Size([32, 64, 2])
w_pred: torch.Size([32, 64, 2])
```

---

### 2.2 L2å±‚ä¸‰å±‚æ¶æ„é›†æˆæ•°æ®æµ

#### L3â†’L2â†’L1 å®Œæ•´æµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           ä¸‰å±‚æ¶æ„æ•°æ®æµ (Three-Tier Integration)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ã€L3å±‚ï¼šVision-Language Modelã€‘
   â”‚
   â”œâ”€ è¾“å…¥ï¼š
   â”‚  â”œâ”€ ä»¿çœŸå›¾åƒ
   â”‚  â”œâ”€ è¯­è¨€æŒ‡ä»¤ (æ–‡æœ¬)
   â”‚  â””â”€ ä¼ æ„Ÿå™¨æ•°æ®ï¼ˆä»¿çœŸï¼‰
   â”‚
   â”œâ”€ å¤„ç†ï¼š
   â”‚  â”œâ”€ åœºæ™¯ç†è§£ä¸è¯­ä¹‰åˆ†å‰²
   â”‚  â”œâ”€ éšœç¢ç‰©æ£€æµ‹ä¸åˆ†ç±»
   â”‚  â”œâ”€ è¯­è¨€æŒ‡ä»¤è§£æ
   â”‚  â””â”€ é£é™©è¯„ä¼°
   â”‚
   â””â”€ è¾“å‡ºç»™L2ï¼š
      â”œâ”€ cost_map: [B, C, H, W]  # è¯­ä¹‰ä»£ä»·åœ°å›¾
      â”‚  â”œâ”€ Cé€šé“åŒ…å«ï¼š
      â”‚  â”‚  â”œâ”€ éšœç¢ç‰©å ç”¨æ¦‚ç‡ [0, 1]
      â”‚  â”‚  â”œâ”€ å¯é€šè¡Œæ€§è¯„åˆ† [0, 1]
      â”‚  â”‚  â””â”€ é£é™©ç­‰çº§ [0, 1]
      â”‚  â””â”€ ç©ºé—´åˆ†è¾¨ç‡: HÃ—W (å¦‚ 64Ã—64 æˆ– 128Ã—128)
      â”‚
      â””â”€ é«˜çº§è¯­ä¹‰æ ‡ç­¾ï¼ˆå¯é€‰ï¼‰

ã€L2å±‚ï¼šSafety-Embedded CFMã€‘æœ¬é¡¹ç›®æ ¸å¿ƒ
   â”‚
   â”œâ”€ è¾“å…¥æ¥æºï¼š
   â”‚  â”œâ”€ ä»L3: cost_map [B, C, H, W]
   â”‚  â”œâ”€ æœºå™¨äººçŠ¶æ€: x_curr [B, 6] = [p_x, p_y, v_x, v_y, a_x, a_y]
   â”‚  â”œâ”€ ç›®æ ‡çŠ¶æ€: x_goal [B, 4] = [p_goal_x, p_goal_y, v_goal_x, v_goal_y]
   â”‚  â””â”€ æ§åˆ¶é£æ ¼æƒé‡: w_style [B, 3] = [w_safety, w_energy, w_smooth]
   â”‚
   â”œâ”€ ã€æ­¥éª¤1ã€‘ä»£ä»·åœ°å›¾ç¼–ç 
   â”‚  â”‚
   â”‚  â”œâ”€ CostMapEncoder.forward(cost_map)
   â”‚  â”‚  â”‚
   â”‚  â”‚  â”œâ”€ CNNç‰¹å¾æå–:
   â”‚  â”‚  â”‚  â”œâ”€ Conv2D(C â†’ 32) + ResBlock â†’ [B, 32, H, W]
   â”‚  â”‚  â”‚  â”œâ”€ Downsample â†’ [B, 64, H/2, W/2]
   â”‚  â”‚  â”‚  â”œâ”€ ResBlock + Downsample â†’ [B, 128, H/4, W/4]
   â”‚  â”‚  â”‚  â”œâ”€ ResBlock + Downsample â†’ [B, 256, H/8, W/8]
   â”‚  â”‚  â”‚  â””â”€ ResBlock + Downsample â†’ [B, 512, H/16, W/16]
   â”‚  â”‚  â”‚
   â”‚  â”‚  â”œâ”€ å…¨å±€æ± åŒ–:
   â”‚  â”‚  â”‚  â””â”€ AdaptiveAvgPool2D â†’ [B, 512]
   â”‚  â”‚  â”‚
   â”‚  â”‚  â””â”€ æŠ•å½±åˆ°æ½œåœ¨ç©ºé—´:
   â”‚  â”‚     â””â”€ Linear(512 â†’ latent_dim) â†’ [B, 256]
   â”‚  â”‚
   â”‚  â””â”€ è¾“å‡º: e_map [B, 256] ä»£ä»·åœ°å›¾çš„æ½œåœ¨è¡¨ç¤º
   â”‚
   â”œâ”€ ã€æ­¥éª¤2ã€‘æ¡ä»¶èåˆ
   â”‚  â”‚
   â”‚  â”œâ”€ L2SafetyCFM.prepare_condition()
   â”‚  â”‚  â”‚
   â”‚  â”‚  â”œâ”€ ç›´æ¥æ‹¼æ¥åŸå§‹æ¡ä»¶å‘é‡:
   â”‚  â”‚  â”‚  cond_vector = cat([x_curr, x_goal, e_map, (å¯é€‰) w_style])
   â”‚  â”‚  â”‚  â””â”€ å½¢çŠ¶: [B, state_dim*3 + state_dim*2 + cost_map_latent_dim (+ style_dim)]
   â”‚  â”‚  â”‚
   â”‚  â”‚  â””â”€ MLP æŠ•å½±åˆ°æ—¶é—´/æ¡ä»¶åµŒå…¥ç©ºé—´:
   â”‚  â”‚     â””â”€ condition_projector(cond_vector) â†’ cond_embed [B, hidden_dim]
   â”‚  â”‚
   â”‚  â””â”€ è¾“å‡º: cond_embed [B, hidden_dim] ç»Ÿä¸€æ¡ä»¶åµŒå…¥
   â”‚
   â”œâ”€ ã€æ­¥éª¤3ã€‘å¤šæ¨¡æ€è½¨è¿¹ç”Ÿæˆ (å¸¦çƒ­å¯åŠ¨å’ŒCBFå®‰å…¨çº¦æŸ)
   â”‚  â”‚
   â”‚  â”œâ”€ L2SafetyCFM.generate_trajectory_anchors()
   â”‚  â”‚  â”‚
   â”‚  â”‚  â”œâ”€ å†…éƒ¨ç»Ÿä¸€è°ƒç”¨ TrajectoryGenerator (cfm_flowmp.inference.generator):
   â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â”œâ”€ ğŸ”„ ã€çƒ­å¯åŠ¨æœºåˆ¶ã€‘ (Warm-Start / On-Policy Memory):
   â”‚  â”‚  â”‚  â”‚  â”‚  å¯ç”¨æ—¶ (GeneratorConfig.enable_warm_start=True):
   â”‚  â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â”‚  â”œâ”€ ç­–ç•¥å»¶ç»­æ¦‚å¿µ:
   â”‚  â”‚  â”‚  â”‚  â”‚  â”œâ”€ tæ—¶åˆ»: L1 MPPIè¾“å‡ºæœ€ä¼˜æ§åˆ¶åºåˆ— u*_t
   â”‚  â”‚  â”‚  â”‚  â”‚  â”œâ”€ t+1æ—¶åˆ»: u*_tå‘å‰ç§»ä½ â†’ Å©_t+1 (ä½œä¸ºå…ˆéªŒ)
   â”‚  â”‚  â”‚  â”‚  â”‚  â””â”€ CFMä»Å©_t+1çš„åŠ å™ªç‰ˆæœ¬å¼€å§‹ï¼Œè€Œéçº¯é«˜æ–¯å™ªå£°
   â”‚  â”‚  â”‚  â”‚  â”‚     â””â”€ ç±»ä¼¼on-policyå¼ºåŒ–å­¦ä¹ ï¼Œå†³ç­–å»ºç«‹åœ¨å…ˆå‰æ­¥éª¤åŸºç¡€ä¸Š
   â”‚  â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â”‚  â”œâ”€ åˆå§‹çŠ¶æ€ç”Ÿæˆ:
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â”‚  â”‚  â”œâ”€ æƒ…å†µ1: æ˜¾å¼warm_start_state (æ¥è‡ªL1/å¤–éƒ¨æ§åˆ¶å™¨)
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â””â”€ x_0 = warm_start_state [B, T, 6]
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â”‚  â”‚  â”œâ”€ æƒ…å†µ2: å†…éƒ¨çƒ­å¯åŠ¨ç¼“å­˜ (enable_warm_start=True)
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â”œâ”€ ä»ç¼“å­˜è·å–ä¸Šä¸€æ—¶åˆ»çš„æœ€ä¼˜è½¨è¿¹ x*_{t-1}
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â”œâ”€ æ—¶é—´ç§»ä½: shift_forward(x*_{t-1}) â†’ xÌƒ_t
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â””â”€ ç§»ä½æ¨¡å¼ (warm_start_shift_mode):
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â”‚     â”œâ”€ "zero_pad": æœ«å°¾è¡¥é›¶ (å‡é€Ÿ/åœæ­¢)
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â”‚     â”œâ”€ "repeat_last": é‡å¤æœ€åçŠ¶æ€ (æ’å®šé€Ÿåº¦)
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â”‚     â””â”€ "predict": çº¿æ€§å¤–æ¨ (é¢„æµ‹å»¶ç»­)
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â””â”€ æ·»åŠ æ¢ç´¢å™ªå£°: x_0 = xÌƒ_t + ÎµÂ·Ïƒ_warm
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚     â””â”€ Ïƒ_warm = warm_start_noise_scale (é»˜è®¤0.1)
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â”‚  â”‚  â””â”€ æƒ…å†µ3: æ ‡å‡†CFM (enable_warm_start=False)
   â”‚  â”‚  â”‚  â”‚  â”‚     â””â”€ x_0 ~ N(0, I) [B, T, 6] çº¯é«˜æ–¯å™ªå£°
   â”‚  â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â”‚  â””â”€ ä¼˜åŠ¿:
   â”‚  â”‚  â”‚  â”‚     â”œâ”€ æ—¶é—´è¿ç»­æ€§: è½¨è¿¹åœ¨æ—¶é—´ä¸Šä¿æŒä¸€è‡´æ€§
   â”‚  â”‚  â”‚  â”‚     â”œâ”€ æ”¶æ•›åŠ é€Ÿ: å‡å°‘CFMæ±‚è§£æ­¥æ•° (å¯ä»20æ­¥â†’8æ­¥)
   â”‚  â”‚  â”‚  â”‚     â””â”€ åŠ¨æ€é€‚åº”: è‡ªåŠ¨é€‚åº”ç¯å¢ƒå’Œç›®æ ‡å˜åŒ–
   â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â”œâ”€ æ„é€  ODE é€Ÿåº¦å‡½æ•°:
   â”‚  â”‚  â”‚  â”‚  velocity_fn(x_t, t) = flow_model(
   â”‚  â”‚  â”‚  â”‚      x_t=x_t, t=t,
   â”‚  â”‚  â”‚  â”‚      start_pos=curr_p, goal_pos=goal_p,
   â”‚  â”‚  â”‚  â”‚      start_vel=curr_v, goal_vel=goal_v,
   â”‚  â”‚  â”‚  â”‚      env_encoding=e_map
   â”‚  â”‚  â”‚  â”‚  )
   â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â”œâ”€ ğŸ›¡ï¸ ã€CBF å®‰å…¨çº¦æŸã€‘ (Control Barrier Function):
   â”‚  â”‚  â”‚  â”‚  â”‚  å¯ç”¨æ—¶ (GeneratorConfig.use_cbf_guidance=True):
   â”‚  â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â”‚  â”œâ”€ å®‰å…¨é›†å®šä¹‰:
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  C_safe = {x | h(x) â‰¥ 0}
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â””â”€ h(x): éšœç¢å‡½æ•° (barrier function)
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚     â”œâ”€ åŸºäºcost_map: h(x) = -cost_map_value(x)
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚     â”œâ”€ åŸºäºéšœç¢ç‰©è·ç¦»: h(x) = ||p-p_obs||Â² - R_safeÂ²
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚     â””â”€ è¾¹ç•Œçº¦æŸ: h(x) = min(1-|p_x|, 1-|p_y|)
   â”‚  â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â”‚  â”œâ”€ CBFä¸å˜æ€§æ¡ä»¶:
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  á¸£(x) + Î±Â·h(x) â‰¥ 0  (Î±ä¸ºclass-Kå‡½æ•°å‚æ•°)
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â””â”€ ç¡®ä¿ç³»ç»Ÿä¸€æ—¦è¿›å…¥å®‰å…¨é›†ï¼Œæ°¸è¿œä¿æŒåœ¨å®‰å…¨é›†å†…
   â”‚  â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â”‚  â”œâ”€ ä¸¤ç§ä½œç”¨æ–¹å¼:
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â”‚  â”‚  â”œâ”€ 1ï¸âƒ£ è®­ç»ƒæ—¶ (FlowMatchingLoss):
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â”œâ”€ CBFçº¦æŸæŸå¤±:
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  L_cbf = Î»_cbf Â· ReLU(-(á¸£ + Î±Â·h))
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â””â”€ æƒ©ç½šè¿åå®‰å…¨æ¡ä»¶çš„è½¨è¿¹
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â”œâ”€ æ€»è®­ç»ƒæŸå¤±:
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  L_total = L_flow_matching + L_cbf
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â””â”€ Î»_cbf: CBFæƒé‡ (é»˜è®¤10.0)
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â””â”€ æ•ˆæœ: æ¨¡å‹å­¦ä¹ éšå¼ç¼–ç å®‰å…¨çº¦æŸ
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â”‚  â”‚  â””â”€ 2ï¸âƒ£ æ¨ç†æ—¶ (ODEæ±‚è§£è¿‡ç¨‹):
   â”‚  â”‚  â”‚  â”‚  â”‚     â”œâ”€ CBFå¼•å¯¼å‡½æ•° (cbf_guidance_fn):
   â”‚  â”‚  â”‚  â”‚  â”‚     â”‚  â”‚
   â”‚  â”‚  â”‚  â”‚  â”‚     â”‚  â”œâ”€ è®¡ç®—éšœç¢å‡½æ•°æ¢¯åº¦: âˆ‡h(x_t)
   â”‚  â”‚  â”‚  â”‚  â”‚     â”‚  â”œâ”€ æ£€æµ‹è¿çº¦: á¸£ + Î±Â·h < 0
   â”‚  â”‚  â”‚  â”‚  â”‚     â”‚  â””â”€ ç”Ÿæˆä¿®æ­£å‘é‡åœº:
   â”‚  â”‚  â”‚  â”‚  â”‚     â”‚     v_correction = Î»_cbf Â· ReLU(-(á¸£+Î±Â·h)) Â· âˆ‡h
   â”‚  â”‚  â”‚  â”‚  â”‚     â”‚     â””â”€ æŒ‡å‘å®‰å…¨åŒºåŸŸçš„æ–¹å‘
   â”‚  â”‚  â”‚  â”‚  â”‚     â”‚
   â”‚  â”‚  â”‚  â”‚  â”‚     â”œâ”€ ä¿®æ­£åçš„å‘é‡åœº:
   â”‚  â”‚  â”‚  â”‚  â”‚     â”‚  vÌ„(x_t, t) = v_model(x_t, t) + v_correction
   â”‚  â”‚  â”‚  â”‚  â”‚     â”‚  â””â”€ åœ¨ODEæ¯ä¸€æ­¥åº”ç”¨ä¿®æ­£
   â”‚  â”‚  â”‚  â”‚  â”‚     â”‚
   â”‚  â”‚  â”‚  â”‚  â”‚     â””â”€ é…ç½®å‚æ•°:
   â”‚  â”‚  â”‚  â”‚  â”‚        â”œâ”€ cbf_weight: ä¿®æ­£å¼ºåº¦ Î»_cbf (é»˜è®¤1.0)
   â”‚  â”‚  â”‚  â”‚  â”‚        â”œâ”€ cbf_margin: å®‰å…¨è£•é‡ R_safe (é»˜è®¤0.1m)
   â”‚  â”‚  â”‚  â”‚  â”‚        â””â”€ cbf_alpha: class-Kå‚æ•° Î± (é»˜è®¤1.0)
   â”‚  â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â”‚  â””â”€ ä¼˜åŠ¿:
   â”‚  â”‚  â”‚  â”‚     â”œâ”€ ç¡¬çº¦æŸä¿è¯: å®æ—¶ä¿®æ­£ç¡®ä¿å®‰å…¨æ€§
   â”‚  â”‚  â”‚  â”‚     â”œâ”€ è¯­ä¹‰æ„ŸçŸ¥: åˆ©ç”¨L3æä¾›çš„cost_map
   â”‚  â”‚  â”‚  â”‚     â””â”€ å¾®åˆ†å¯å¯¼: æ— ç¼é›†æˆåˆ°ODEæ±‚è§£ä¸­
   â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â”œâ”€ ä¸ºæ¯ä¸ªæ ·æœ¬ç”Ÿæˆ N æ¡å€™é€‰è½¨è¿¹:
   â”‚  â”‚  â”‚  â”‚  â”œâ”€ é‡å¤æ¡ä»¶: (curr_p, goal_p, curr_v, goal_v, e_map) â†’ [BÃ—N, ...]
   â”‚  â”‚  â”‚  â”‚  â”œâ”€ é‡‡æ ·/å‡†å¤‡åˆå§‹çŠ¶æ€ x_0 (æ ¹æ®çƒ­å¯åŠ¨é…ç½®) â†’ [BÃ—N, T, 6]
   â”‚  â”‚  â”‚  â”‚  â”œâ”€ ä½¿ç”¨ç»Ÿä¸€ ODE æ±‚è§£å™¨ (RK4 + 8-step è°ƒåº¦):
   â”‚  â”‚  â”‚  â”‚  â”‚  â”œâ”€ æ—¶é—´è°ƒåº¦: t âˆˆ [0.0, 0.8, 0.85, 0.9, 0.92, 0.94, 0.96, 0.98, 1.0]
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â””â”€ å‰æœŸå¤§æ­¥é•¿(æ¢ç´¢)ï¼ŒåæœŸå°æ­¥é•¿(ç»†åŒ–)
   â”‚  â”‚  â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â”‚  â”‚  â””â”€ æ¯ä¸ªRK4æ­¥éª¤ (å¸¦å¯é€‰CBFå¼•å¯¼):
   â”‚  â”‚  â”‚  â”‚  â”‚     k1 = velocity_fn(x_t, t) + cbf_guidance(x_t, k1) 
   â”‚  â”‚  â”‚  â”‚  â”‚     k2 = velocity_fn(x_t + Î”t/2Â·k1, t+Î”t/2) + cbf_guidance(...)
   â”‚  â”‚  â”‚  â”‚  â”‚     k3 = velocity_fn(x_t + Î”t/2Â·k2, t+Î”t/2) + cbf_guidance(...)
   â”‚  â”‚  â”‚  â”‚  â”‚     k4 = velocity_fn(x_t + Î”tÂ·k3, t+Î”t) + cbf_guidance(...)
   â”‚  â”‚  â”‚  â”‚  â”‚     x_{t+Î”t} = x_t + Î”t/6Â·(k1 + 2k2 + 2k3 + k4)
   â”‚  â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â”‚  â””â”€ å¾—åˆ° x_1 [BÃ—N, T, 6] = [p, v, a]
   â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â”œâ”€ (å¯é€‰) ä½¿ç”¨ BSplineSmoother åš B-spline å¹³æ»‘ï¼Œæ¶ˆé™¤æ•°å€¼å™ªå£°
   â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â””â”€ (å¯é€‰) å¤šæ¨¡æ€é”šç‚¹ç­›é€‰ (enable_multimodal_anchors=True):
   â”‚  â”‚  â”‚     â”œâ”€ ä»Næ¡è½¨è¿¹ä¸­è¯†åˆ«Kä¸ªåŒä¼¦ç±» (homotopy classes)
   â”‚  â”‚  â”‚     â”‚  â”œâ”€ æå–ç‰¹å¾: ä¸­ç‚¹ä½ç½®ã€æ›²ç‡ã€ç»ˆç‚¹ä½ç½®
   â”‚  â”‚  â”‚     â”‚  â”œâ”€ K-Meansèšç±»: åˆ†æˆK=4ä¸ªç°‡
   â”‚  â”‚  â”‚     â”‚  â””â”€ é€‰æ‹©æ¯ç°‡çš„ä»£è¡¨è½¨è¿¹ (è·ç¦»èšç±»ä¸­å¿ƒæœ€è¿‘)
   â”‚  â”‚  â”‚     â”‚
   â”‚  â”‚  â”‚     â””â”€ è¾“å‡ºKæ¡ç¦»æ•£é”šç‚¹è½¨è¿¹ç»™L1 MPPI
   â”‚  â”‚  â”‚        â””â”€ ä»£è¡¨ä¸åŒçš„æ‹“æ‰‘è·¯å¾„é€‰æ‹© (å¦‚: å·¦ç»•ã€ä¸­ç©¿ã€å³ç»•)
   â”‚  â”‚  â”‚
   â”‚  â”‚  â””â”€ L2SafetyCFM å¯¹è¿”å›ç»“æœé‡å‘½åä»¥ä¿æŒæ¥å£ç¨³å®š:
   â”‚  â”‚     â”œâ”€ trajectories â† positions   [BÃ—K, T, 2] (K=num_anchorsæˆ–N)
   â”‚  â”‚     â”œâ”€ velocities  â† velocities  [BÃ—K, T, 2]
   â”‚  â”‚     â””â”€ accelerations â† accelerations [BÃ—K, T, 2]
   â”‚  â”‚
   â”‚  â””â”€ è¾“å‡º: 
   â”‚     â”œâ”€ trajectories [BÃ—K, T, 2] ä½ç½®è½¨è¿¹ (K=64æˆ–ç»è¿‡ç­›é€‰çš„é”šç‚¹æ•°)
   â”‚     â”œâ”€ velocities [BÃ—K, T, 2] é€Ÿåº¦è½¨è¿¹
   â”‚     â”œâ”€ accelerations [BÃ—K, T, 2] åŠ é€Ÿåº¦è½¨è¿¹
   â”‚     â”œâ”€ metadata (å¯é€‰): æ¯æ¡è½¨è¿¹çš„è´¨é‡è¯„åˆ†ã€å®‰å…¨æ€§è¯„ä¼°
   â”‚     â””â”€ ğŸ”„ æ›´æ–°çƒ­å¯åŠ¨ç¼“å­˜ (å¦‚å¯ç”¨): 
   â”‚        â””â”€ warm_start_cache â† x_1 (ç”¨äºä¸‹ä¸€æ—¶åˆ»)
   â”‚
   â””â”€ è¾“å‡ºç»™L1ï¼š
      â””â”€ trajectory_anchors = {
         'trajectories': [BÃ—64, T, 2],
         'velocities': [BÃ—64, T, 2],
         'accelerations': [BÃ—64, T, 2]
      }

ã€L1å±‚ï¼šModel Predictive Path Integral (MPPI)ã€‘
   â”‚
   â”œâ”€ è¾“å…¥æ¥æºï¼š
   â”‚  â”œâ”€ ä»L2: trajectory_anchors (Kæ¡å€™é€‰è½¨è¿¹, K=4~64)
   â”‚  â”œâ”€ å½“å‰æœºå™¨äººçŠ¶æ€
   â”‚  â””â”€ å®æ—¶ä¼ æ„Ÿå™¨æ•°æ®
   â”‚
   â”œâ”€ å¤„ç†ï¼š
   â”‚  â”œâ”€ è½¨è¿¹é”šç‚¹é€‰æ‹©:
   â”‚  â”‚  â”œâ”€ è¯„ä¼°Kæ¡è½¨è¿¹çš„å±€éƒ¨ä»£ä»·
   â”‚  â”‚  â”‚  â””â”€ è€ƒè™‘: ç¢°æ’é£é™©ã€åŠ¨åŠ›å­¦å¯è¡Œæ€§ã€æ‰§è¡Œå™¨é™åˆ¶
   â”‚  â”‚  â”œâ”€ é€‰æ‹©top-Næ¡ä½œä¸ºwarm-start (N=1~8)
   â”‚  â”‚  â””â”€ æˆ–ä½¿ç”¨åŠ æƒç»„åˆ
   â”‚  â”‚
   â”‚  â”œâ”€ å±€éƒ¨é‡‡æ ·ä¼˜åŒ–:
   â”‚  â”‚  â”œâ”€ åœ¨é€‰å®šé”šç‚¹é™„è¿‘é‡‡æ ·æ‰°åŠ¨
   â”‚  â”‚  â”œâ”€ å‰å‘rolloutè¯„ä¼°ä»£ä»·
   â”‚  â”‚  â””â”€ è®¡ç®—æœ€ä¼˜æ§åˆ¶åºåˆ— u*_t
   â”‚  â”‚
   â”‚  â””â”€ å®æ—¶çº¦æŸæ£€æŸ¥:
   â”‚     â”œâ”€ åŠ¨åŠ›å­¦çº¦æŸ
   â”‚     â”œâ”€ ç¢°æ’æ£€æµ‹
   â”‚     â””â”€ æ‰§è¡Œå™¨é™åˆ¶
   â”‚
   â””â”€ è¾“å‡ºï¼š
      â”œâ”€ æœ€ä¼˜æ§åˆ¶è¾“å…¥ u_optimal [horizon_length]
      â”œâ”€ é¢„æµ‹è½¨è¿¹ Ï„*_t [T, state_dim]
      â”œâ”€ æ‰§è¡Œä¸‹ä¸€æ­¥æ§åˆ¶
      â””â”€ ğŸ”„ (å¯é€‰) å›ä¼ ç»™L2ç”¨äºçƒ­å¯åŠ¨:
         â””â”€ optimal_trajectory â†’ L2.warm_start_cache
            â””â”€ åœ¨ä¸‹ä¸€æ—¶åˆ»t+1ï¼ŒL2ä½¿ç”¨Ï„*_tä½œä¸ºå…ˆéªŒ

ã€å…³é”®æ•°æ®æµæ¥å£ã€‘

L3 â†’ L2:
  - cost_map: [B, C, H, W] torch.Tensor, dtype=float32
  - åŒ…å«è¯­ä¹‰é£é™©ã€å¯é€šè¡Œæ€§ã€éšœç¢ç‰©ä¿¡æ¯

L2 â†’ L1:
  - trajectories: [BÃ—N, T, 2] torch.Tensor, dtype=float32
  - velocities: [BÃ—N, T, 2] torch.Tensor, dtype=float32
  - accelerations: [BÃ—N, T, 2] torch.Tensor, dtype=float32
  - N=64æ¡å¤šæ¨¡æ€å€™é€‰ï¼ŒT=åºåˆ—é•¿åº¦ï¼Œ2Dç©ºé—´

ã€æ§åˆ¶é£æ ¼æƒé‡æ•ˆæœã€‘

w_style = [w_safety, w_energy, w_smooth]:
  - w_safetyé«˜ â†’ è¿œç¦»éšœç¢ç‰©ï¼Œä¿å®ˆè·¯å¾„
  - w_energyé«˜ â†’ æœ€çŸ­è·¯å¾„ï¼Œæ¿€è¿›è¡Œä¸º
  - w_smoothé«˜ â†’ å¹³æ»‘æ›²çº¿ï¼Œèˆ’é€‚è¿åŠ¨

ç¤ºä¾‹é…ç½®:
  - ä¿å®ˆæ¨¡å¼: [0.7, 0.1, 0.2] - å®‰å…¨ä¼˜å…ˆ
  - å¹³è¡¡æ¨¡å¼: [0.4, 0.3, 0.3] - ç»¼åˆè€ƒè™‘
  - é«˜æ•ˆæ¨¡å¼: [0.2, 0.5, 0.3] - æ•ˆç‡ä¼˜å…ˆ

ã€ğŸ”„ çƒ­å¯åŠ¨æœºåˆ¶é…ç½®ã€‘

GeneratorConfigçƒ­å¯åŠ¨å‚æ•°:
  â”œâ”€ enable_warm_start: bool = False
  â”‚  â””â”€ æ˜¯å¦å¯ç”¨çƒ­å¯åŠ¨æœºåˆ¶
  â”‚
  â”œâ”€ warm_start_noise_scale: float = 0.1
  â”‚  â””â”€ çƒ­å¯åŠ¨åˆå§‹çŠ¶æ€çš„å™ªå£°å°ºåº¦ (æ¢ç´¢vsåˆ©ç”¨å¹³è¡¡)
  â”‚     â”œâ”€ 0.0: çº¯åˆ©ç”¨ï¼Œå®Œå…¨å¤ç”¨ä¸Šä¸€æ—¶åˆ»è½¨è¿¹
  â”‚     â”œâ”€ 0.1-0.3: æ¨èèŒƒå›´ï¼Œé€‚åº¦æ¢ç´¢
  â”‚     â””â”€ >0.5: é«˜æ¢ç´¢ï¼Œæ¥è¿‘æ ‡å‡†CFM
  â”‚
  â”œâ”€ warm_start_shift_mode: str = "zero_pad"
  â”‚  â””â”€ è½¨è¿¹æ—¶é—´ç§»ä½çš„å¡«å……ç­–ç•¥
  â”‚     â”œâ”€ "zero_pad": æœ«å°¾è¡¥é›¶ â†’ é€‚åˆéœ€è¦åœæ­¢çš„åœºæ™¯
  â”‚     â”œâ”€ "repeat_last": é‡å¤æœ€åçŠ¶æ€ â†’ é€‚åˆæ’é€Ÿè¿åŠ¨
  â”‚     â””â”€ "predict": çº¿æ€§å¤–æ¨ â†’ é€‚åˆå¹³æ»‘å»¶ç»­
  â”‚
  â””â”€ warm_start_memory_length: int = 1
     â””â”€ è®°ä½çš„å…ˆå‰è½¨è¿¹æ•°é‡ (å½“å‰ä»…æ”¯æŒ1)

ä½¿ç”¨åœºæ™¯:
  â”œâ”€ âœ… å®æ—¶é—­ç¯æ§åˆ¶ (MPCå¼è¿ç»­è§„åˆ’)
  â”œâ”€ âœ… åŠ¨æ€é¿éšœ (éšœç¢ç‰©ä½ç½®éšæ—¶é—´å˜åŒ–)
  â”œâ”€ âœ… ç›®æ ‡è·Ÿè¸ª (ç›®æ ‡ä½ç½®å®æ—¶æ›´æ–°)
  â””â”€ âŒ å•æ¬¡è§„åˆ’ä»»åŠ¡ (æ— éœ€çƒ­å¯åŠ¨)

APIè°ƒç”¨ç¤ºä¾‹:
  # æ–¹å¼1: æ˜¾å¼ä¼ å…¥warm_start_state
  result = generator.generate(
      start_pos, goal_pos,
      warm_start_state=previous_trajectory  # [B, T, 6] æ¥è‡ªL1 MPPI
  )
  
  # æ–¹å¼2: ä½¿ç”¨å†…éƒ¨ç¼“å­˜ (è‡ªåŠ¨ç®¡ç†)
  config = GeneratorConfig(enable_warm_start=True, ...)
  generator = TrajectoryGenerator(model, config)
  for t in range(T_horizon):
      result = generator.generate(start_pos, goal_pos)
      # generatorè‡ªåŠ¨ç¼“å­˜resultç”¨äºä¸‹ä¸€æ—¶åˆ»

ã€ğŸ›¡ï¸ CBF å®‰å…¨çº¦æŸé…ç½®ã€‘

è®­ç»ƒæ—¶é…ç½® (FlowMatchingConfig):
  â”œâ”€ use_cbf_constraint: bool = False
  â”‚  â””â”€ è®­ç»ƒæ—¶æ˜¯å¦å¯ç”¨CBFæŸå¤±
  â”‚
  â”œâ”€ cbf_weight: float = 10.0
  â”‚  â””â”€ CBFæŸå¤±æƒé‡ Î»_cbf
  â”‚     â”œâ”€ 0.0: ç¦ç”¨CBFçº¦æŸ
  â”‚     â”œâ”€ 1.0-10.0: æ¨èèŒƒå›´ï¼Œæ¸©å’Œçº¦æŸ
  â”‚     â””â”€ >20.0: å¼ºçº¦æŸï¼Œå¯èƒ½å½±å“è½¨è¿¹è´¨é‡
  â”‚
  â”œâ”€ cbf_margin: float = 0.1
  â”‚  â””â”€ å®‰å…¨è£•é‡ R_safe (å•ä½: ç±³)
  â”‚     â””â”€ æœºå™¨äººä¸éšœç¢ç‰©çš„æœ€å°å…è®¸è·ç¦»
  â”‚
  â””â”€ cbf_alpha: float = 1.0
     â””â”€ class-Kå‡½æ•°å‚æ•° Î±
        â””â”€ æ§åˆ¶å®‰å…¨é›†æ”¶æ•›é€Ÿåº¦

æ¨ç†æ—¶é…ç½® (GeneratorConfig):
  â”œâ”€ use_cbf_guidance: bool = False
  â”‚  â””â”€ æ¨ç†æ—¶æ˜¯å¦å¯ç”¨CBFå¼•å¯¼
  â”‚
  â”œâ”€ cbf_weight: float = 1.0
  â”‚  â””â”€ å¼•å¯¼ä¿®æ­£å¼ºåº¦ (æ¨ç†æ—¶é€šå¸¸å°äºè®­ç»ƒæ—¶)
  â”‚
  â”œâ”€ cbf_margin: float = 0.1
  â”œâ”€ cbf_alpha: float = 1.0
  â””â”€ (åŒè®­ç»ƒæ—¶)

éšœç¢ä¿¡æ¯æ¥æº:
  â”œâ”€ cost_map: [B, H, W] - ä»L3å±‚è·å–çš„è¯­ä¹‰ä»£ä»·å›¾ (æ¨è)
  â”‚  â””â”€ æä¾›å…¨å±€ç¯å¢ƒé£é™©åˆ†å¸ƒ
  â”‚
  â”œâ”€ obstacle_positions: [N_obs, D] - æ˜¾å¼éšœç¢ç‰©ä½ç½®
  â”‚  â””â”€ ç®€åŒ–åœºæ™¯ï¼Œå‡ ä½•éšœç¢ç‰©
  â”‚
  â””â”€ é»˜è®¤: è¾¹ç•Œçº¦æŸ (å•ä½æ­£æ–¹å½¢å†…)

ä½¿ç”¨åœºæ™¯:
  â”œâ”€ âœ… ç¨ å¯†éšœç¢ç‰©ç¯å¢ƒ
  â”œâ”€ âœ… å®‰å…¨å…³é”®åº”ç”¨ (åŒ»ç–—æœºå™¨äººã€è‡ªåŠ¨é©¾é©¶)
  â”œâ”€ âœ… åŠ¨æ€éšœç¢ç‰© (ä¸çƒ­å¯åŠ¨ç»“åˆ)
  â””â”€ âŒ ç®€å•å¼€æ”¾ç©ºé—´ (å¼•å…¥ä¸å¿…è¦çš„è®¡ç®—å¼€é”€)

APIè°ƒç”¨ç¤ºä¾‹:
  # è®­ç»ƒæ—¶
  loss_fn = FlowMatchingLoss(
      FlowMatchingConfig(
          use_cbf_constraint=True,
          cbf_weight=10.0,
          cbf_margin=0.1
      )
  )
  loss_dict = loss_fn(
      model_output, target,
      trajectory=interpolated_traj,
      cost_map=cost_maps  # ä»è®­ç»ƒæ•°æ®
  )
  
  # æ¨ç†æ—¶
  config = GeneratorConfig(
      use_cbf_guidance=True,
      cbf_weight=1.0,
      cbf_margin=0.1
  )
  result = generator.generate(
      start_pos, goal_pos,
      cost_map=current_cost_map,  # ä»L3å±‚å®æ—¶è·å–
      obstacle_positions=detected_obstacles  # å¯é€‰
  )

ã€ğŸ”„+ğŸ›¡ï¸ çƒ­å¯åŠ¨ä¸CBFè”åˆä½¿ç”¨ã€‘

è”åˆé…ç½®æ¨è:
  config = GeneratorConfig(
      # çƒ­å¯åŠ¨
      enable_warm_start=True,
      warm_start_noise_scale=0.15,  # é€‚åº¦æ¢ç´¢
      warm_start_shift_mode="predict",  # å¹³æ»‘å»¶ç»­
      
      # CBFå®‰å…¨çº¦æŸ
      use_cbf_guidance=True,
      cbf_weight=1.5,  # é€‚ä¸­å¼ºåº¦
      cbf_margin=0.15,  # ç•¥å¤§çš„å®‰å…¨è£•é‡
      
      # ODEæ±‚è§£å™¨
      solver_type="rk4",
      use_8step_schedule=True,  # çƒ­å¯åŠ¨å…è®¸æ›´æ¿€è¿›çš„æ­¥é•¿
  )

ååŒæ•ˆåº”:
  â”œâ”€ çƒ­å¯åŠ¨æä¾›æ—¶é—´è¿ç»­çš„å…ˆéªŒ
  â”‚  â””â”€ CBFä»æ›´å¥½çš„åˆå§‹çŠ¶æ€å¼€å§‹ä¿®æ­£
  â”‚
  â”œâ”€ CBFç¡®ä¿æ¯æ­¥éƒ½æ»¡è¶³å®‰å…¨çº¦æŸ
  â”‚  â””â”€ çƒ­å¯åŠ¨ä¸ä¼šä¼ æ’­ä¸å®‰å…¨çš„è½¨è¿¹
  â”‚
  â””â”€ å…±åŒå®ç°: å¿«é€Ÿã€å®‰å…¨ã€æ—¶é—´ä¸€è‡´çš„è½¨è¿¹ç”Ÿæˆ

å…¸å‹æ§åˆ¶å¾ªç¯:
  for t in control_horizon:
      # 1. ä»L3è·å–æœ€æ–°è¯­ä¹‰ä¿¡æ¯
      cost_map = l3_vlm.get_cost_map(current_scene)
      
      # 2. L2ç”Ÿæˆå¤šæ¨¡æ€å®‰å…¨è½¨è¿¹ (å¸¦çƒ­å¯åŠ¨+CBF)
      anchors = l2_cfm.generate_trajectory_anchors(
          cost_map=cost_map,
          x_curr=robot_state,
          x_goal=target_state
      )
      
      # 3. L1 MPPIå±€éƒ¨ä¼˜åŒ–é€‰æ‹©æœ€ä¼˜è½¨è¿¹
      optimal_traj = l1_mppi.optimize(anchors)
      
      # 4. æ‰§è¡Œç¬¬ä¸€æ­¥æ§åˆ¶
      robot.execute(optimal_traj[0])
      
      # 5. L2è‡ªåŠ¨ç¼“å­˜optimal_trajç”¨äºä¸‹ä¸€æ—¶åˆ»çƒ­å¯åŠ¨
      # (å¦‚æœenable_warm_start=Trueï¼Œè‡ªåŠ¨å¤„ç†)
```

---

#### çƒ­å¯åŠ¨ä¸CBFæ—¶åºæµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         é—­ç¯æ§åˆ¶ä¸­çš„çƒ­å¯åŠ¨ä¸CBFæ—¶åºå…³ç³» (Temporal Flow)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ—¶åˆ» t=0 (åˆå§‹æ—¶åˆ»):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  L3: cost_mapâ‚€ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                                     â”‚
  L2: xâ‚€ ~ N(0,I) â”€â”€â”€â”€â†’ [ODE+CBF] â”€â”€â”€â”€â†’ Ï„_anchorsâ‚€ â”¤
       (çº¯é«˜æ–¯å™ªå£°)      (8æ­¥RK4)                    â”‚
       æ— çƒ­å¯åŠ¨                                      â”‚
                                                     â”œâ”€â”€â†’ L1: MPPIä¼˜åŒ–
  CBF: âˆ‡h(x) å®æ—¶ä¿®æ­£ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â†“
       ç¡®ä¿ á¸£+Î±Â·h â‰¥ 0                                      u*â‚€, Ï„*â‚€
                                                               â†“
  Robot: æ‰§è¡Œ u*â‚€[0] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ çŠ¶æ€æ›´æ–°
                                                               â†“
  ğŸ”„ ç¼“å­˜: warm_start_cache â† Ï„*â‚€ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                                                             â•‘
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•‘â”â”â”â”
æ—¶åˆ» t=1:                                                    â•‘
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•‘â”â”â”â”
                                                             â•‘
  L3: cost_mapâ‚ (æ›´æ–°) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â•‘
                                                        â”‚    â•‘
  L2: ğŸ”„ xâ‚ = shift(Ï„*â‚€) + ÎµÂ·Ïƒ â”€â”€â”€â”€â†’ [ODE+CBF] â”€â”€â”€â”€â†’ Ï„_anchorsâ‚
       (çƒ­å¯åŠ¨å…ˆéªŒ)  â†‘                  CBFå¼•å¯¼         â”‚
            â•”â•â•â•â•â•â•â•â•â•                                 â”‚
            â•‘                                          â”œâ”€â”€â†’ L1: MPPIä¼˜åŒ–
  CBF: åŸºäºcost_mapâ‚ä¿®æ­£ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â†“
       h(x) = -cost_mapâ‚(x)                                u*â‚, Ï„*â‚
                                                               â†“
  Robot: æ‰§è¡Œ u*â‚[0] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ çŠ¶æ€æ›´æ–°
                                                               â†“
  ğŸ”„ ç¼“å­˜: warm_start_cache â† Ï„*â‚ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                                                             â•‘
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•‘â”â”â”â”
æ—¶åˆ» t=2 (åŠ¨æ€éšœç¢ç‰©å‡ºç°):                                   â•‘
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•‘â”â”â”â”
                                                             â•‘
  L3: cost_mapâ‚‚ (æ–°éšœç¢ç‰©!) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â•‘
       h(x)å€¼åœ¨éšœç¢ç‰©é™„è¿‘æ€¥å‰§ä¸‹é™                      â”‚     â•‘
                                                        â”‚     â•‘
  L2: ğŸ”„ xâ‚‚ = shift(Ï„*â‚) + ÎµÂ·Ïƒ â”€â”€â”€â”€â†’ [ODE+CBF] â”€â”€â”€â”€â†’ Ï„_anchorsâ‚‚
       (çƒ­å¯åŠ¨æä¾›åˆç†å…ˆéªŒ)     â†‘        â•‘            â”‚
            â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•        â•‘            â”‚
            â•‘                             â•‘            â”‚
  CBF: ğŸ›¡ï¸ æ£€æµ‹åˆ°è¿çº¦: á¸£+Î±Â·h < 0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â•           â”‚
       ä¿®æ­£å‘é‡: v_corr = Î»Â·ReLU(-...)Â·âˆ‡h            â”œâ”€â”€â†’ L1: MPPI
       å®æ—¶æ¨å¼€éšœç¢ç‰©æ–¹å‘                             â”‚      å¿«é€Ÿé‡è§„åˆ’
                                                        â”‚         â†“
  Robot: æ‰§è¡Œ u*â‚‚[0] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’     u*â‚‚, Ï„*â‚‚
       å®‰å…¨é¿è®©æ–°éšœç¢ç‰©                                        â†“
                                                          çŠ¶æ€æ›´æ–°
  ğŸ”„ ç¼“å­˜: warm_start_cache â† Ï„*â‚‚ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                                                             â•‘
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•‘â”â”â”â”
æ—¶åˆ» t=3 (æ¥è¿‘ç›®æ ‡):                                         â•‘
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•‘â”â”â”â”
                                                             â•‘
  L3: cost_mapâ‚ƒ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â•‘
       éšœç¢ç‰©è¿œç¦»ï¼Œæ¥è¿‘ç›®æ ‡åŒºåŸŸ                         â”‚   â•‘
                                                        â”‚   â•‘
  L2: ğŸ”„ xâ‚ƒ = shift(Ï„*â‚‚) + ÎµÂ·Ïƒ_reduced â”€â”€â†’ [ODE+CBF] â”€â”€â†’ Ï„_anchorsâ‚ƒ
       (Ïƒè‡ªé€‚åº”é™ä½ï¼Œåˆ©ç”¨>æ¢ç´¢)    â•‘                    â”‚
            â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                   â”‚
            â•‘                                           â”‚
  CBF: h(x) > 0 å…¨ç¨‹æ»¡è¶³ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       å®‰å…¨é›†ä¸å˜æ€§å¾—åˆ°ä¿è¯                              â”‚
                                                        â”‚
  L1: é€‰æ‹©å¹³æ»‘æ”¶æ•›è½¨è¿¹ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       u*â‚ƒ = soft_stop_control                          â†“
                                                    u*â‚ƒ, Ï„*â‚ƒ
  Robot: å¹³æ»‘åœé åˆ°ç›®æ ‡ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ ä»»åŠ¡å®Œæˆ âœ“
       â†“
  ğŸ”„ é‡ç½®: warm_start_cache = None (ä»»åŠ¡ç»“æŸï¼Œæ¸…ç©ºç¼“å­˜)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ã€å…³é”®æ—¶åºç‰¹æ€§ã€‘

1. çƒ­å¯åŠ¨çš„æ—¶é—´ä¼ æ’­:
   Ï„*_{t-1} â”€â”€[shift]â”€â”€â†’ xÌƒ_t â”€â”€[+noise]â”€â”€â†’ x_t â”€â”€[ODE]â”€â”€â†’ Ï„*_t
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      ç­–ç•¥å»¶ç»­ (Policy Continuation)

2. CBFçš„å®æ—¶ä¿æŠ¤:
   æ¯ä¸ªODEæ­¥ (t_i â†’ t_{i+1}):
     if á¸£ + Î±Â·h < 0:  # è¿çº¦æ£€æµ‹
         v â† v + Î»_cbf Â· âˆ‡h  # ç«‹å³ä¿®æ­£
   ç¡®ä¿è½¨è¿¹å§‹ç»ˆæ»¡è¶³å®‰å…¨çº¦æŸ

3. L3-L2-L1çš„ä¿¡æ¯æµ:
   L3 â”€[cost_map]â†’ L2 â”€[CBF h(x)]â†’ ODEæ±‚è§£å™¨
                   â†“
                L1 MPPI â”€[Ï„*]â†’ L2ç¼“å­˜ (ä¸‹ä¸€æ—¶åˆ»)
                   â†“
                Robotæ‰§è¡Œ

4. æ€§èƒ½æå‡:
   â”œâ”€ æ— çƒ­å¯åŠ¨: ~20æ­¥ODEæ±‚è§£, ~200mså»¶è¿Ÿ
   â”œâ”€ æœ‰çƒ­å¯åŠ¨: ~8æ­¥ODEæ±‚è§£, ~80mså»¶è¿Ÿ (2.5xåŠ é€Ÿ)
   â””â”€ çƒ­å¯åŠ¨+CBF: åŒæ ·å¿«é€Ÿ + å®‰å…¨ä¿è¯

5. é²æ£’æ€§:
   â”œâ”€ ç›®æ ‡å˜åŒ–: çƒ­å¯åŠ¨å¿«é€Ÿé€‚åº”æ–°ç›®æ ‡
   â”œâ”€ éšœç¢ç‰©å‡ºç°: CBFå®æ—¶ä¿®æ­£é¿è®©
   â””â”€ ä¼ æ„Ÿå™¨å™ªå£°: L3è¯­ä¹‰ç†è§£è¿‡æ»¤å™ªå£°
```

---

#### L2å±‚è®­ç»ƒæ•°æ®éœ€æ±‚

```
è®­ç»ƒæ•°æ®æ ¼å¼ (ç”¨äºL2å±‚):

å¿…éœ€æ•°æ®:
â”œâ”€ trajectories: [N_samples, T, 2]  # ä¸“å®¶è½¨è¿¹ï¼ˆä½ç½®ï¼‰
â”œâ”€ velocities: [N_samples, T, 2]    # é€Ÿåº¦
â”œâ”€ accelerations: [N_samples, T, 2] # åŠ é€Ÿåº¦
â”œâ”€ cost_maps: [N_samples, C, H, W]  # å¯¹åº”çš„åœºæ™¯ä»£ä»·åœ°å›¾
â”œâ”€ start_states: [N_samples, 6]     # åˆå§‹çŠ¶æ€ [p, v, a]
â”œâ”€ goal_states: [N_samples, 4]      # ç›®æ ‡çŠ¶æ€ [p, v]
â””â”€ style_weights: [N_samples, 3]    # æ§åˆ¶é£æ ¼ [w_safety, w_energy, w_smooth]

å¯é€‰æ•°æ®:
â”œâ”€ scene_images: [N_samples, 3, H_img, W_img]  # RGBå›¾åƒï¼ˆå¦‚éœ€ç«¯åˆ°ç«¯è®­ç»ƒï¼‰
â”œâ”€ safety_margins: [N_samples]                  # æ¯æ¡è½¨è¿¹çš„å®‰å…¨ä½™é‡
â””â”€ trajectory_quality: [N_samples]              # è½¨è¿¹è´¨é‡æ ‡ç­¾

æ•°æ®æ¥æº:
1. äººç±»æ¼”ç¤ºæ•°æ®ï¼ˆé¥æ“ä½œã€VRå½•åˆ¶ï¼‰
2. ä¸“å®¶ç­–ç•¥ç”Ÿæˆï¼ˆå¦‚è·¯å¾„è§„åˆ’ç®—æ³•ï¼‰
3. æ¨¡æ‹Ÿå™¨é‡‡æ ·ï¼ˆå¦‚Gazeboã€Isaac Simï¼‰
4. çœŸå®æœºå™¨äººæ•°æ®é‡‡é›†
```

---

### 2.3 æ¨ç†é˜¶æ®µæ•°æ®æµ

#### å®Œæ•´æµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   æ¨ç†æ•°æ®æµ (Inference Flow)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. åˆå§‹åŒ–ä¸è¾“å…¥å‡†å¤‡ (Initialization)
   â”‚
   â”œâ”€ åŠ è½½é¢„è®­ç»ƒæ¨¡å‹
   â”‚  â”œâ”€ ä» checkpoint æ–‡ä»¶åŠ è½½
   â”‚  â”œâ”€ è®¾ç½®ä¸ºè¯„ä¼°æ¨¡å¼: model.eval()
   â”‚  â”œâ”€ ç¦ç”¨æ¢¯åº¦è®¡ç®—: torch.no_grad()
   â”‚  â””â”€ å¯é€‰ï¼šç§»è‡³ GPU
   â”‚
   â”œâ”€ è®¾ç½®ç”Ÿæˆå™¨é…ç½® (GeneratorConfig)
   â”‚  â”œâ”€ solver_type: "rk4" (æˆ– "euler", "midpoint", "rk45")
   â”‚  â”œâ”€ time_schedule: è‡ªå®šä¹‰æ—¶é—´æ­¥ (æˆ– None è‡ªåŠ¨ç”Ÿæˆ)
   â”‚  â”œâ”€ num_steps: 20 (ä»…åœ¨ time_schedule=None æ—¶ä½¿ç”¨)
   â”‚  â”œâ”€ use_bspline_smoothing: True (B-spline åå¤„ç†)
   â”‚  â”œâ”€ bspline_degree: 3
   â”‚  â””â”€ state_dim, seq_len: æ¨¡å‹å‚æ•°
   â”‚
   â””â”€ è¾“å…¥æ¡ä»¶å‡†å¤‡
      â”œâ”€ start_pos: [B, D] èµ·å§‹ä½ç½®
      â”‚  â””â”€ ä¾‹å¦‚: [[0.0, 0.0], [1.0, 1.0]] for B=2
      â”‚
      â”œâ”€ goal_pos: [B, D] ç›®æ ‡ä½ç½®
      â”‚  â””â”€ ä¾‹å¦‚: [[2.0, 2.0], [3.0, 1.0]] for B=2
      â”‚
      â””â”€ start_vel: [B, D] (å¯é€‰) èµ·å§‹é€Ÿåº¦
         â””â”€ é»˜è®¤: [[0.0, 0.0], [0.0, 0.0]]

2. å™ªå£°é‡‡æ · (Noise Sampling)
   â”‚
   â””â”€ é«˜æ–¯åˆ†å¸ƒé‡‡æ ·
      â”‚
      â”œâ”€ é‡‡æ ·åˆå§‹çŠ¶æ€:
      â”‚  x_0 ~ N(0, I) â†’ [B, T, 6]
      â”‚  â””â”€ åˆ†è§£ä¸º:
      â”‚     â”œâ”€ pos_0: [B, T, D] ~ N(0, 1)
      â”‚     â”œâ”€ vel_0: [B, T, D] ~ N(0, 1)
      â”‚     â””â”€ acc_0: [B, T, D] ~ N(0, 1)
      â”‚
      â””â”€ ç›®çš„ï¼šä¸º ODE æ±‚è§£æä¾›åˆå§‹æ¡ä»¶
         â””â”€ t=0 æ—¶ï¼Œx_0 æ˜¯çº¯å™ªå£°
         â””â”€ t=1 æ—¶ï¼Œx_1 åº”è¯¥æ˜¯æœ‰æ•ˆè½¨è¿¹

3. ODE æ±‚è§£ (ODE Integration)
   â”‚
   â”œâ”€ ã€ç¬¬ä¸€æ­¥ã€‘å‡†å¤‡æ—¶é—´è°ƒåº¦
   â”‚  â”‚
   â”‚  â”œâ”€ é€‰é¡¹ 1: å‡åŒ€è°ƒåº¦
   â”‚  â”‚  â””â”€ time_schedule = np.linspace(0, 1, num_steps)
   â”‚  â”‚  â””â”€ ä¾‹: [0.00, 0.05, 0.10, ..., 0.95, 1.00]
   â”‚  â”‚
   â”‚  â”œâ”€ é€‰é¡¹ 2: 8 æ­¥éå‡åŒ€è°ƒåº¦ (æ¨èï¼Œå¿«é€Ÿæ¨ç†)
   â”‚  â”‚  â””â”€ time_schedule = [0.0, 0.8, 0.85, 0.9, 0.92, 0.94, 0.96, 0.98, 1.0]
   â”‚  â”‚  â””â”€ ç‰¹ç‚¹ï¼šæ—©æœŸå¤§æ­¥é•¿ï¼ˆå¿«é€Ÿå»å™ªï¼‰ï¼ŒåæœŸå°æ­¥é•¿ï¼ˆç²¾ç»†è°ƒæ•´ï¼‰
   â”‚  â”‚
   â”‚  â””â”€ é€‰é¡¹ 3: è‡ªå®šä¹‰è°ƒåº¦
   â”‚     â””â”€ ç”¨æˆ·æä¾›çš„è‡ªå®šä¹‰æ—¶é—´ç‚¹åˆ—è¡¨
   â”‚
   â”œâ”€ ã€ç¬¬äºŒæ­¥ã€‘å®šä¹‰é€Ÿåº¦å‡½æ•°
   â”‚  â”‚
   â”‚  â”œâ”€ velocity_fn(x_t, t) çš„ä½œç”¨ï¼š
   â”‚  â”‚  â””â”€ æ ¹æ®å½“å‰çŠ¶æ€å’Œæ—¶é—´ï¼Œè®¡ç®—å˜åŒ–ç‡ dx/dt
   â”‚  â”‚
   â”‚  â”œâ”€ å®ç°ï¼š
   â”‚  â”‚  â”‚
   â”‚  â”‚  â”œâ”€ æ‰©å±•æ—¶é—´ t:
   â”‚  â”‚  â”‚  â”‚ å¦‚æœ t æ˜¯æ ‡é‡ï¼Œéœ€è¦æ‰©å±•ä¸º [B] çš„å½¢çŠ¶
   â”‚  â”‚  â”‚  â”‚ t_expanded: [1] â†’ [B]
   â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”œâ”€ æ¨¡å‹å‰å‘:
   â”‚  â”‚  â”‚  â”‚ output = model(x_t, t_expanded, start_pos, goal_pos, start_vel)
   â”‚  â”‚  â”‚  â”‚ output: [B, T, 6]
   â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â””â”€ è¿”å›ï¼š[B, T, 6] å‘é‡åœºå€¼
   â”‚  â”‚
   â”‚  â””â”€ ç›®çš„ï¼šæä¾› ODE æ±‚è§£å™¨æ‰€éœ€çš„å¯¼æ•°ä¿¡æ¯
   â”‚
   â”œâ”€ ã€ç¬¬ä¸‰æ­¥ã€‘RK4 ODE æ±‚è§£
   â”‚  â”‚
   â”‚  â”œâ”€ ç®—æ³•ï¼š4 é˜¶ Runge-Kutta æ–¹æ³•
   â”‚  â”‚  â”‚
   â”‚  â”‚  â”œâ”€ åˆå§‹åŒ–: x_current = x_0 [B, T, 6]
   â”‚  â”‚  â”‚
   â”‚  â”‚  â””â”€ å¯¹æ¯ä¸€å¯¹æ—¶é—´æ­¥ (t_i, t_{i+1}):
   â”‚  â”‚     â”‚
   â”‚  â”‚     â”œâ”€ dt = t_{i+1} - t_i
   â”‚  â”‚     â”‚
   â”‚  â”‚     â”œâ”€ è®¡ç®— 4 ä¸ªæ–œç‡:
   â”‚  â”‚     â”‚  â”‚
   â”‚  â”‚     â”‚  â”œâ”€ k1 = velocity_fn(x_current, t_i)  [B, T, 6]
   â”‚  â”‚     â”‚  â”‚  â””â”€ åœ¨å½“å‰ç‚¹çš„æ–œç‡
   â”‚  â”‚     â”‚  â”‚
   â”‚  â”‚     â”‚  â”œâ”€ k2 = velocity_fn(x_current + 0.5*dt*k1, t_i + 0.5*dt)  [B, T, 6]
   â”‚  â”‚     â”‚  â”‚  â””â”€ åœ¨ä¸­ç‚¹å¤„å‘å‰çœ‹ 1/2 æ­¥çš„æ–œç‡
   â”‚  â”‚     â”‚  â”‚
   â”‚  â”‚     â”‚  â”œâ”€ k3 = velocity_fn(x_current + 0.5*dt*k2, t_i + 0.5*dt)  [B, T, 6]
   â”‚  â”‚     â”‚  â”‚  â””â”€ å¦ä¸€ç§ä¸­ç‚¹ä¼°è®¡
   â”‚  â”‚     â”‚  â”‚
   â”‚  â”‚     â”‚  â””â”€ k4 = velocity_fn(x_current + dt*k3, t_i + dt)  [B, T, 6]
   â”‚  â”‚     â”‚     â””â”€ åœ¨ä¸‹ä¸€ä¸ªç‚¹çš„æ–œç‡
   â”‚  â”‚     â”‚
   â”‚  â”‚     â””â”€ åŠ æƒå¹³å‡æ›´æ–°:
   â”‚  â”‚        x_{i+1} = x_i + (dt/6) * (k1 + 2*k2 + 2*k3 + k4)
   â”‚  â”‚        â””â”€ åŠ æƒç»„åˆ 4 ä¸ªæ–œç‡ä¼°è®¡
   â”‚  â”‚
   â”‚  â”œâ”€ ç²¾åº¦ä¸æˆæœ¬ï¼š
   â”‚  â”‚  â”œâ”€ 20 æ­¥: O(h^4) ç²¾åº¦ï¼Œå¿«é€Ÿ
   â”‚  â”‚  â”œâ”€ 50 æ­¥: O(h^4) ç²¾åº¦ï¼Œæ›´ç²¾ç¡®ä½†è¾ƒæ…¢
   â”‚  â”‚  â””â”€ 8 æ­¥éå‡åŒ€: æœ€å¿«ï¼Œä¿ç•™ç»†èŠ‚
   â”‚  â”‚
   â”‚  â””â”€ è¾“å‡ºï¼šx_1 [B, T, 6]ï¼ˆt=1 æ—¶çš„çŠ¶æ€ï¼‰
   â”‚
   â”œâ”€ ã€ç¬¬å››æ­¥ã€‘æå–è½¨è¿¹åˆ†é‡
   â”‚  â”‚
   â”‚  â”œâ”€ x_1: [B, T, 6]
   â”‚  â”‚
   â”‚  â”œâ”€ åˆ†è§£æ–¹å¼:
   â”‚  â”‚  â”œâ”€ positions_raw = x_1[..., :D]  [B, T, D]
   â”‚  â”‚  â”œâ”€ velocities_raw = x_1[..., D:2*D]  [B, T, D]
   â”‚  â”‚  â””â”€ accelerations_raw = x_1[..., 2*D:3*D]  [B, T, D]
   â”‚  â”‚
   â”‚  â””â”€ ç‰¹ç‚¹ï¼š
   â”‚     â”œâ”€ ä½ç½®æ˜¯è¿ç»­çš„å…‰æ»‘è½¨è¿¹
   â”‚     â”œâ”€ é€Ÿåº¦å¯èƒ½æœ‰å™ªå£°ï¼ˆODE ç§¯åˆ†è¯¯å·®ï¼‰
   â”‚     â””â”€ åŠ é€Ÿåº¦æœ€å˜ˆæ‚ï¼ˆäºŒé˜¶å¯¼æ•°æ”¾å¤§è¯¯å·®ï¼‰
   â”‚
   â””â”€ ã€ç¬¬äº”æ­¥ã€‘å»å™ªå¤„ç† (å¯é€‰ï¼Œè‹¥æœ‰å™ªå£°)
      â””â”€ å¯¹é€Ÿåº¦å’ŒåŠ é€Ÿåº¦è¿›è¡Œå¹³æ»‘å¤„ç†

4. åå¤„ç†ï¼šB-spline å¹³æ»‘ (Post-processing)
   â”‚
   â”œâ”€ BSplineSmoother.smooth() çš„ç›®çš„ï¼š
   â”‚  â”œâ”€ æ¶ˆé™¤ ODE ç§¯åˆ†å¼•å…¥çš„æ•°å€¼å™ªå£°
   â”‚  â”œâ”€ ç¡®ä¿é€Ÿåº¦å’ŒåŠ é€Ÿåº¦çš„ç‰©ç†ä¸€è‡´æ€§
   â”‚  â”œâ”€ å‡å°‘é«˜é¢‘æŒ¯è¡
   â”‚  â””â”€ æ”¹å–„è½¨è¿¹çš„å…‰æ»‘æ€§
   â”‚
   â”œâ”€ å¤„ç†æµç¨‹ (å¯¹æ¯ä¸ªæ ·æœ¬):
   â”‚  â”‚
   â”‚  â”œâ”€ ã€ä½ç½®å¹³æ»‘ã€‘:
   â”‚  â”‚  â”‚
   â”‚  â”‚  â”œâ”€ å¯¹ä½ç½®è½¨è¿¹ positions [T, D]:
   â”‚  â”‚  â”‚  â”œâ”€ å¯¹æ¯ä¸ªç»´åº¦å•ç‹¬å¤„ç†:
   â”‚  â”‚  â”‚  â”‚  â”œâ”€ æ‹Ÿåˆ B-spline æ›²çº¿ (degree=3, é€šå¸¸ cubic spline)
   â”‚  â”‚  â”‚  â”‚  â”‚  â””â”€ positions_1d: [T] â†’ BSplineæ›²çº¿
   â”‚  â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â”‚  â””â”€ é‡æ–°é‡‡æ ·åˆ°åŸå§‹æ—¶é—´ç‚¹:
   â”‚  â”‚  â”‚  â”‚     â”œâ”€ ç”Ÿæˆå‡åŒ€çš„å‚æ•°å€¼: u = linspace(0, 1, T)
   â”‚  â”‚  â”‚  â”‚     â””â”€ åœ¨ u ä¸Šè¯„ä¼° B-spline
   â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â””â”€ è¾“å‡ºï¼šå¹³æ»‘ä½ç½® pos_smooth [T, D]
   â”‚  â”‚  â”‚
   â”‚  â”‚  â””â”€ ç»“æœï¼šæ¶ˆé™¤äº†ä½ç½®å™ªå£°
   â”‚  â”‚
   â”‚  â”œâ”€ ã€é€Ÿåº¦é‡æ–°è®¡ç®—ã€‘:
   â”‚  â”‚  â”‚
   â”‚  â”‚  â”œâ”€ æ–¹æ³•ï¼šä»å¹³æ»‘ä½ç½®è®¡ç®—å¯¼æ•°
   â”‚  â”‚  â”‚
   â”‚  â”‚  â”œâ”€ å®ç°ï¼š
   â”‚  â”‚  â”‚  â”œâ”€ é€šè¿‡ä¸­å¿ƒå·®åˆ†è®¡ç®—é€Ÿåº¦:
   â”‚  â”‚  â”‚  â”‚  vel[i] = (pos[i+1] - pos[i-1]) / (2 * dt)
   â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â”œâ”€ è¾¹ç•Œå¤„ç†:
   â”‚  â”‚  â”‚  â”‚  vel[0] = (pos[1] - pos[0]) / dt
   â”‚  â”‚  â”‚  â”‚  vel[-1] = (pos[-1] - pos[-2]) / dt
   â”‚  â”‚  â”‚  â”‚
   â”‚  â”‚  â”‚  â””â”€ è¾“å‡ºï¼šé€Ÿåº¦ vel_smooth [T, D]
   â”‚  â”‚  â”‚
   â”‚  â”‚  â””â”€ ç»“æœï¼šé€Ÿåº¦ä¸ä½ç½®ä¸€è‡´ï¼Œæ¶ˆé™¤äº†ä¸è¿ç»­
   â”‚  â”‚
   â”‚  â””â”€ ã€åŠ é€Ÿåº¦é‡æ–°è®¡ç®—ã€‘:
   â”‚     â”‚
   â”‚     â”œâ”€ åŒæ ·ä»å¹³æ»‘é€Ÿåº¦è®¡ç®—:
   â”‚     â”‚  acc[i] = (vel[i+1] - vel[i-1]) / (2 * dt)
   â”‚     â”‚
   â”‚     â””â”€ è¾“å‡ºï¼šåŠ é€Ÿåº¦ acc_smooth [T, D]
   â”‚
   â”œâ”€ å¹³æ»‘å‚æ•°:
   â”‚  â”œâ”€ bspline_degree: 3 (cubic, é€šå¸¸æœ€ä¼˜)
   â”‚  â”œâ”€ smoothing_factor: æ§åˆ¶æ‹Ÿåˆç´§å¯†åº¦
   â”‚  â””â”€ knots: B-spline èŠ‚ç‚¹æ•°
   â”‚
   â””â”€ è¾“å‡ºå¼ é‡:
      â”œâ”€ positions: [B, T, D] å¹³æ»‘ä½ç½®è½¨è¿¹
      â”œâ”€ velocities: [B, T, D] å¹³æ»‘é€Ÿåº¦è½¨è¿¹
      â””â”€ accelerations: [B, T, D] å¹³æ»‘åŠ é€Ÿåº¦è½¨è¿¹

5. æœ€ç»ˆè¾“å‡º (Final Output)
   â”‚
   â””â”€ ç»“æœå­—å…¸:
      â”œâ”€ 'positions': [B, T, D]
      â”‚  â””â”€ å¹³æ»‘çš„ç©ºé—´è½¨è¿¹
      â”‚
      â”œâ”€ 'velocities': [B, T, D]
      â”‚  â””â”€ ä¸ä½ç½®ä¸€è‡´çš„é€Ÿåº¦
      â”‚
      â”œâ”€ 'accelerations': [B, T, D]
      â”‚  â””â”€ ä¸€è‡´çš„åŠ é€Ÿåº¦
      â”‚
      â””â”€ (å¯é€‰) 'raw_positions': [B, T, D]
         â””â”€ æœªå¹³æ»‘çš„åŸå§‹è¾“å‡º (ç”¨äºè°ƒè¯•)
```

#### æ•°æ®ç»´åº¦è¿½è¸ªç¤ºä¾‹

```python
# æ¨ç†å‚æ•°: B=5, T=64, D=2

# è¾“å…¥æ¡ä»¶
start_pos: torch.Size([5, 2])  # 5 ä¸ªè½¨è¿¹ï¼Œ2D ä½ç½®
goal_pos: torch.Size([5, 2])
start_vel: torch.Size([5, 2])

# åˆå§‹å™ªå£°
x_0: torch.Size([5, 64, 6])  # 5 ä¸ªæ‰¹æ¬¡ï¼Œ64 æ—¶é—´æ­¥ï¼Œ6 ç»´çŠ¶æ€

# ODE æ±‚è§£è¿‡ç¨‹ï¼ˆæ¯ä¸ªæ—¶é—´æ­¥ï¼‰
t_i: float  # å½“å‰æ—¶é—´
x_current: torch.Size([5, 64, 6])  # å½“å‰çŠ¶æ€

# é€Ÿåº¦å‡½æ•°è°ƒç”¨
velocity_output: torch.Size([5, 64, 6])  # æ¨¡å‹è¾“å‡ºçš„å‘é‡åœº

# RK4 æ–œç‡
k1, k2, k3, k4: torch.Size([5, 64, 6])  # 4 ä¸ªæ–œç‡
x_next: torch.Size([5, 64, 6])  # ä¸‹ä¸€æ—¶é—´æ­¥çŠ¶æ€

# ODE æ±‚è§£å®Œæˆ
x_1: torch.Size([5, 64, 6])  # æœ€ç»ˆçŠ¶æ€

# åˆ†è§£
positions_raw: torch.Size([5, 64, 2])
velocities_raw: torch.Size([5, 64, 2])
accelerations_raw: torch.Size([5, 64, 2])

# B-spline å¹³æ»‘å
positions_smooth: torch.Size([5, 64, 2])
velocities_smooth: torch.Size([5, 64, 2])
accelerations_smooth: torch.Size([5, 64, 2])
```

#### æ¨ç†ç®—æ³•ä¼ªä»£ç 

```python
def inference(model, start_pos, goal_pos, start_vel, config):
    B = start_pos.shape[0]  # æ‰¹æ¬¡å¤§å°
    T = config.seq_len      # æ—¶é—´æ­¥æ•°
    D = config.state_dim    # çŠ¶æ€ç»´åº¦
    
    # ç¬¬ä¸€æ­¥ï¼šé‡‡æ ·åˆå§‹å™ªå£°
    x_0 = torch.randn(B, T, 6)
    
    # ç¬¬äºŒæ­¥ï¼šå‡†å¤‡æ—¶é—´è°ƒåº¦
    if config.use_8step_schedule:
        times = [0.0, 0.8, 0.85, 0.9, 0.92, 0.94, 0.96, 0.98, 1.0]
    else:
        times = np.linspace(0, 1, config.num_steps)
    
    # ç¬¬ä¸‰æ­¥ï¼šå®šä¹‰é€Ÿåº¦å‡½æ•°
    def velocity_fn(x_t, t):
        # æ‰©å±• t ä¸ºæ‰¹æ¬¡å½¢çŠ¶
        t_batch = torch.full((B,), t, device=x_t.device)
        # æ¨¡å‹å‰å‘
        output = model(x_t, t_batch, start_pos, goal_pos, start_vel)
        return output  # [B, T, 6]
    
    # ç¬¬å››æ­¥ï¼šRK4 ODE æ±‚è§£
    x_current = x_0
    for i in range(len(times) - 1):
        t_i = times[i]
        t_next = times[i + 1]
        dt = t_next - t_i
        
        # è®¡ç®— 4 ä¸ªæ–œç‡
        k1 = velocity_fn(x_current, t_i)
        k2 = velocity_fn(x_current + 0.5*dt*k1, t_i + 0.5*dt)
        k3 = velocity_fn(x_current + 0.5*dt*k2, t_i + 0.5*dt)
        k4 = velocity_fn(x_current + dt*k3, t_next)
        
        # æ›´æ–°çŠ¶æ€
        x_current = x_current + (dt/6) * (k1 + 2*k2 + 2*k3 + k4)
    
    x_1 = x_current
    
    # ç¬¬äº”æ­¥ï¼šæå–åˆ†é‡
    positions = x_1[..., :D]
    velocities = x_1[..., D:2*D]
    accelerations = x_1[..., 2*D:3*D]
    
    # ç¬¬å…­æ­¥ï¼šB-spline å¹³æ»‘ï¼ˆå¯é€‰ï¼‰
    if config.use_bspline_smoothing:
        positions = bspline_smooth(positions)
        # é‡æ–°è®¡ç®—é€Ÿåº¦å’ŒåŠ é€Ÿåº¦ä»¥ä¿æŒä¸€è‡´æ€§
        velocities = compute_derivatives(positions)
        accelerations = compute_derivatives(velocities)
    
    return {
        'positions': positions,      # [B, T, D]
        'velocities': velocities,    # [B, T, D]
        'accelerations': accelerations  # [B, T, D]
    }
```

### 2.3 ç½‘ç»œæ¶æ„è¯¦è§£ (Network Architecture)

#### FlowMPTransformer çš„å®Œæ•´ç»“æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   FlowMPTransformer æ¶æ„                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ã€æ¨¡å— 0ã€‘è¾“å…¥å¤„ç†å±‚
â”œâ”€ è¾“å…¥: x_t [B, T, 6]  (ä½ç½®ã€é€Ÿåº¦ã€åŠ é€Ÿåº¦æ‹¼æ¥)
â”œâ”€ æ¡ä»¶: start_pos [B, D], goal_pos [B, D], start_vel [B, D]
â”œâ”€ æ—¶é—´: t [B]
â”‚
â”œâ”€ ç¬¬ä¸€æ­¥ï¼šè¾“å…¥çº¿æ€§æŠ•å½±
â”‚  â”œâ”€ Linear(6, hidden_dim)
â”‚  â”œâ”€ ä½œç”¨ï¼šå°† 6 ç»´çŠ¶æ€æ˜ å°„åˆ°éšè—ç©ºé—´
â”‚  â”œâ”€ ç»´åº¦å˜åŒ–: [B, T, 6] â†’ [B, T, hidden_dim]
â”‚  â””â”€ å‚æ•°é‡: 6 * hidden_dim + hidden_dim (åç½®)
â”‚
â”œâ”€ ç¬¬äºŒæ­¥ï¼šåŠ å…¥ä½ç½®ç¼–ç  (Positional Encoding)
â”‚  â”‚
â”‚  â”œâ”€ ç±»å‹ï¼šæ­£å¼¦ä½ç½®ç¼–ç ï¼ˆæ ‡å‡† Transformer æ–¹å¼ï¼‰
â”‚  â”‚
â”‚  â”œâ”€ å…¬å¼:
â”‚  â”‚  PE(pos, 2i) = sin(pos / 10000^(2i/d))
â”‚  â”‚  PE(pos, 2i+1) = cos(pos / 10000^(2i/d))
â”‚  â”‚  å…¶ä¸­ pos æ˜¯æ—¶é—´æ­¥ç´¢å¼• (0, 1, 2, ..., T-1)
â”‚  â”‚       d æ˜¯éšè—ç»´åº¦
â”‚  â”‚
â”‚  â”œâ”€ ç»´åº¦: [T, hidden_dim]
â”‚  â”‚
â”‚  â”œâ”€ æ·»åŠ æ–¹å¼: x' = x + PE
â”‚  â”‚  â””â”€ é€å…ƒç´ ç›¸åŠ ï¼Œå½¢çŠ¶å¹¿æ’­
â”‚  â”‚
â”‚  â””â”€ è¾“å‡º: [B, T, hidden_dim]
â”‚
â”œâ”€ ç¬¬ä¸‰æ­¥ï¼šæ—¶é—´åµŒå…¥ (Time Embedding)
â”‚  â”‚
â”‚  â”œâ”€ æ–¹æ³•ï¼šGaussian Fourier æŠ•å½±
â”‚  â”‚
â”‚  â”œâ”€ è¿‡ç¨‹ï¼š
â”‚  â”‚  â”‚
â”‚  â”‚  â”œâ”€ é‡‡æ ·é¢‘ç‡å‘é‡:
â”‚  â”‚  â”‚  â”œâ”€ b ~ N(0, ÏƒÂ²) [num_fourier_features]
â”‚  â”‚  â”‚  â””â”€ Ïƒ é€šå¸¸å– 1.0 æˆ– 16.0ï¼ˆå¯é…ç½®ï¼‰
â”‚  â”‚  â”‚
â”‚  â”‚  â”œâ”€ å‚…é‡Œå¶æŠ•å½±ï¼ˆå¯¹æ¯ä¸ªæ ·æœ¬ t ~ [0, 1]ï¼‰:
â”‚  â”‚  â”‚  â”œâ”€ sin_features = sin(2Ï€ * t * b)  [num_fourier_features]
â”‚  â”‚  â”‚  â”œâ”€ cos_features = cos(2Ï€ * t * b)  [num_fourier_features]
â”‚  â”‚  â”‚  â””â”€ concat([sin_features, cos_features])  [2*num_fourier_features]
â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€ çº¿æ€§å±‚å°†å‚…é‡Œå¶ç‰¹å¾æ˜ å°„åˆ°éšè—ç»´:
â”‚  â”‚     Linear(2*num_fourier_features, cond_dim)
â”‚  â”‚
â”‚  â”œâ”€ ç»´åº¦å˜åŒ–: [B] â†’ [B, cond_dim]
â”‚  â”‚
â”‚  â””â”€ ä½œç”¨ï¼š
â”‚     â”œâ”€ æ•æ‰æ—¶é—´çš„å‘¨æœŸæ€§ä¿¡æ¯
â”‚     â”œâ”€ ä½¿æ¨¡å‹èƒ½å¤Ÿå­¦ä¹ æ—¶é—´ç›¸å…³çš„åŠ¨æ€
â”‚     â””â”€ ä¸º AdaLN æä¾›æ¡ä»¶å‚æ•°
â”‚
â”œâ”€ ç¬¬å››æ­¥ï¼šæ¡ä»¶ç¼–ç  (Condition Encoder)
â”‚  â”‚
â”‚  â”œâ”€ è¾“å…¥æ‹¼æ¥:
â”‚  â”‚  â””â”€ concat([start_pos, goal_pos, start_vel])
â”‚  â”‚  â””â”€ ç»´åº¦: [B, 5*D]  (3 ä¸ª D ç»´å‘é‡)
â”‚  â”‚
â”‚  â”œâ”€ çº¿æ€§æŠ•å½±:
â”‚  â”‚  â””â”€ Linear(5*D, cond_dim)
â”‚  â”‚  â””â”€ ç»´åº¦: [B, cond_dim]
â”‚  â”‚
â”‚  â””â”€ ä½œç”¨ï¼š
â”‚     â”œâ”€ ç¼–ç èµ·ç‚¹ã€ç›®æ ‡å’Œåˆé€Ÿåº¦ä¿¡æ¯
â”‚     â”œâ”€ ä¸ºç”Ÿæˆè¿‡ç¨‹æä¾›çº¦æŸæ¡ä»¶
â”‚     â””â”€ é€šè¿‡ AdaLN æ³¨å…¥åˆ°ç½‘ç»œå„å±‚
â”‚
â””â”€ ç¬¬äº”æ­¥ï¼šæ¡ä»¶èåˆ (Condition Fusion)
   â”‚
   â”œâ”€ ç»„åˆæ—¶é—´å’Œæ¡ä»¶:
   â”‚  â”œâ”€ combined_cond = time_emb + cond_emb
   â”‚  â”œâ”€ ç»´åº¦: [B, cond_dim]
   â”‚  â””â”€ æ–¹å¼ï¼šé€å…ƒç´ ç›¸åŠ ï¼ˆæˆ–å¯é€‰è¿æ¥åçº¿æ€§æ˜ å°„ï¼‰
   â”‚
   â””â”€ ç”¨é€”ï¼šç”¨äº AdaLN çš„å‚æ•°ç”Ÿæˆ

ã€æ¨¡å— 1 åˆ° L-1ã€‘Transformer ç¼–ç å™¨å— (Ã—L å±‚)

æ³¨æ„ï¼šæ¯å±‚çš„å¤„ç†æ­¥éª¤å®Œå…¨ç›¸åŒï¼Œåªæœ‰å‚æ•°ä¸åŒ

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Block i (i = 0, 1, ..., L-1)                             â”‚
â”‚                                                           â”‚
â”‚ è¾“å…¥: x [B, T, hidden_dim]                              â”‚
â”‚ æ¡ä»¶: combined_cond [B, cond_dim]                        â”‚
â”‚                                                           â”‚
â”‚ â‘  AdaLN (Adaptive Layer Normalization)                 â”‚
â”‚    â”‚                                                       â”‚
â”‚    â”œâ”€ è®¡ç®— Î³ å’Œ Î²:                                        â”‚
â”‚    â”‚  â”œâ”€ Î³ = Linear_gamma(combined_cond) [B, hidden_dim] â”‚
â”‚    â”‚  â””â”€ Î² = Linear_beta(combined_cond) [B, hidden_dim]  â”‚
â”‚    â”‚                                                       â”‚
â”‚    â”œâ”€ å¯¹æ‰€æœ‰åºåˆ—ä½ç½®åº”ç”¨è‡ªé€‚åº”å½’ä¸€åŒ–:                      â”‚
â”‚    â”‚  â”œâ”€ è®¡ç®—ç»Ÿè®¡é‡: Î¼ = mean(x, dim=-1) [B, T]          â”‚
â”‚    â”‚  â”‚               Ïƒ = std(x, dim=-1) [B, T]           â”‚
â”‚    â”‚  â”‚                                                    â”‚
â”‚    â”‚  â”œâ”€ å½’ä¸€åŒ–: x_norm = (x - Î¼) / Ïƒ                    â”‚
â”‚    â”‚  â”‚                                                    â”‚
â”‚    â”‚  â””â”€ è‡ªé€‚åº”å˜æ¢: y = Î³ * x_norm + Î²                  â”‚
â”‚    â”‚     (Î³ å’Œ Î² å¯¹æ‰€æœ‰æ—¶é—´æ­¥é‡å¤åº”ç”¨)                   â”‚
â”‚    â”‚                                                       â”‚
â”‚    â””â”€ è¾“å‡º: [B, T, hidden_dim]                           â”‚
â”‚                                                           â”‚
â”‚ â‘¡ Multi-Head Self-Attention                             â”‚
â”‚    â”‚                                                       â”‚
â”‚    â”œâ”€ Q, K, V æŠ•å½±:                                      â”‚
â”‚    â”‚  â”œâ”€ Q = Linear_q(x)  [B, T, hidden_dim]             â”‚
â”‚    â”‚  â”œâ”€ K = Linear_k(x)  [B, T, hidden_dim]             â”‚
â”‚    â”‚  â””â”€ V = Linear_v(x)  [B, T, hidden_dim]             â”‚
â”‚    â”‚                                                       â”‚
â”‚    â”œâ”€ åˆ†å¤´:                                               â”‚
â”‚    â”‚  â”œâ”€ num_heads = hidden_dim / head_dim                â”‚
â”‚    â”‚  â”œâ”€ Q: [B, T, hidden_dim] â†’ [B, num_heads, T, head_dim] â”‚
â”‚    â”‚  â”œâ”€ K: [B, T, hidden_dim] â†’ [B, num_heads, T, head_dim] â”‚
â”‚    â”‚  â””â”€ V: [B, T, hidden_dim] â†’ [B, num_heads, T, head_dim] â”‚
â”‚    â”‚                                                       â”‚
â”‚    â”œâ”€ ç¼©æ”¾ç‚¹ç§¯æ³¨æ„åŠ› (Scaled Dot-Product Attention):      â”‚
â”‚    â”‚  â”‚                                                    â”‚
â”‚    â”‚  â”œâ”€ scores = Q @ K^T / âˆšhead_dim                    â”‚
â”‚    â”‚  â”‚   ç»´åº¦: [B, num_heads, T, T]                     â”‚
â”‚    â”‚  â”‚                                                    â”‚
â”‚    â”‚  â”œâ”€ attention_weights = softmax(scores)              â”‚
â”‚    â”‚  â”‚   ç»´åº¦: [B, num_heads, T, T]                     â”‚
â”‚    â”‚  â”‚                                                    â”‚
â”‚    â”‚  â”œâ”€ attention_output = attention_weights @ V         â”‚
â”‚    â”‚  â”‚   ç»´åº¦: [B, num_heads, T, head_dim]              â”‚
â”‚    â”‚  â”‚                                                    â”‚
â”‚    â”‚  â””â”€ å«ä¹‰ï¼šæ¯ä¸ªä½ç½®å­¦ä¹ å…³æ³¨å…¶ä»–ä½ç½®çš„ä¿¡æ¯             â”‚
â”‚    â”‚                                                       â”‚
â”‚    â”œâ”€ åˆå¹¶å¤šå¤´:                                           â”‚
â”‚    â”‚  â””â”€ concat(heads) â†’ [B, T, hidden_dim]              â”‚
â”‚    â”‚                                                       â”‚
â”‚    â”œâ”€ è¾“å‡ºæŠ•å½±:                                           â”‚
â”‚    â”‚  â””â”€ Linear_out(concat) â†’ [B, T, hidden_dim]         â”‚
â”‚    â”‚                                                       â”‚
â”‚    â”œâ”€ æ®‹å·®è¿æ¥:                                           â”‚
â”‚    â”‚  â””â”€ output = x + attention_output                    â”‚
â”‚    â”‚                                                       â”‚
â”‚    â””â”€ è¾“å‡º: [B, T, hidden_dim]                           â”‚
â”‚                                                           â”‚
â”‚ â‘¢ AdaLN (ç¬¬äºŒæ¬¡)                                         â”‚
â”‚    â”‚                                                       â”‚
â”‚    â”œâ”€ åŒâ‘  çš„è¿‡ç¨‹ï¼Œä½¿ç”¨ç›¸åŒçš„ Î³ å’Œ Î²                     â”‚
â”‚    â”‚                                                       â”‚
â”‚    â””â”€ è¾“å‡º: [B, T, hidden_dim]                           â”‚
â”‚                                                           â”‚
â”‚ â‘£ Feed-Forward Network (FFN)                            â”‚
â”‚    â”‚                                                       â”‚
â”‚    â”œâ”€ ç»“æ„: Linear â†’ æ¿€æ´»å‡½æ•° â†’ Linear                    â”‚
â”‚    â”‚                                                       â”‚
â”‚    â”œâ”€ è¯¦ç»†è¿‡ç¨‹:                                           â”‚
â”‚    â”‚  â”œâ”€ ffn_hidden = Linear1(x)  [B, T, ffn_dim]        â”‚
â”‚    â”‚  â”‚  å…¶ä¸­ ffn_dim = 4 * hidden_dim (æ ‡å‡†é…ç½®)         â”‚
â”‚    â”‚  â”‚                                                    â”‚
â”‚    â”‚  â”œâ”€ activated = ReLU(ffn_hidden)  [B, T, ffn_dim]   â”‚
â”‚    â”‚  â”‚  (æˆ– GELU, SiLU ç­‰æ¿€æ´»å‡½æ•°)                      â”‚
â”‚    â”‚  â”‚                                                    â”‚
â”‚    â”‚  â”œâ”€ ffn_output = Linear2(activated)  [B, T, hidden_dim] â”‚
â”‚    â”‚  â”‚                                                    â”‚
â”‚    â”‚  â””â”€ å«ä¹‰ï¼šé€ä½ç½®çš„éçº¿æ€§å˜æ¢ï¼Œæ‰©å±•è¡¨ç¤ºèƒ½åŠ›           â”‚
â”‚    â”‚                                                       â”‚
â”‚    â”œâ”€ æ®‹å·®è¿æ¥:                                           â”‚
â”‚    â”‚  â””â”€ output = x + ffn_output                          â”‚
â”‚    â”‚                                                       â”‚
â”‚    â””â”€ è¾“å‡º: [B, T, hidden_dim]                           â”‚
â”‚                                                           â”‚
â”‚ æœ¬å—è¾“å‡º: [B, T, hidden_dim]                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ã€æ¨¡å— Lã€‘æœ€åçš„å½’ä¸€åŒ–å’Œè¾“å‡ºå¤´

â”œâ”€ æœ€å AdaLN å±‚:
â”‚  â”œâ”€ å¯¹æ•´ä¸ªåºåˆ—åº”ç”¨æœ€åçš„è‡ªé€‚åº”å½’ä¸€åŒ–
â”‚  â””â”€ ç»´åº¦: [B, T, hidden_dim] â†’ [B, T, hidden_dim]
â”‚
â””â”€ è¾“å‡ºå¤´ (Output Head):
   â”‚
   â”œâ”€ çº¿æ€§æ˜ å°„:
   â”‚  â””â”€ Linear(hidden_dim, 6)
   â”‚  â””â”€ ç»´åº¦: [B, T, hidden_dim] â†’ [B, T, 6]
   â”‚
   â”œâ”€ åˆ†è§£è¾“å‡ºå‘é‡åœº:
   â”‚  â”œâ”€ u_pred = output[..., :D]          # [B, T, D] ä½ç½®é€Ÿåº¦åœº
   â”‚  â”œâ”€ v_pred = output[..., D:2*D]      # [B, T, D] åŠ é€Ÿåº¦åœº
   â”‚  â””â”€ w_pred = output[..., 2*D:3*D]    # [B, T, D] æ€¥åŠ¨åœº
   â”‚
   â””â”€ è¾“å‡º: [B, T, 6] å®Œæ•´å‘é‡åœºé¢„æµ‹
```

#### å‚æ•°é…ç½®ä¸è®¡ç®—

```python
# æ¨¡å‹å˜ä½“é…ç½®
MODEL_CONFIG = {
    "small": {
        "hidden_dim": 128,
        "num_layers": 4,
        "num_heads": 4,
        "ffn_dim": 512,  # 4 * hidden_dim
        "head_dim": 32,  # hidden_dim / num_heads
        "cond_dim": 64,
        "num_fourier": 32,
        "num_params": "~3M",
    },
    "base": {
        "hidden_dim": 256,
        "num_layers": 6,
        "num_heads": 8,
        "ffn_dim": 1024,
        "head_dim": 32,
        "cond_dim": 128,
        "num_fourier": 64,
        "num_params": "~12M",
    },
    "large": {
        "hidden_dim": 512,
        "num_layers": 8,
        "num_heads": 16,
        "ffn_dim": 2048,
        "head_dim": 32,
        "cond_dim": 256,
        "num_fourier": 128,
        "num_params": "~50M",
    },
}

# å‚æ•°é‡è®¡ç®—ç¤ºä¾‹ (base ç‰ˆæœ¬)
# å‡è®¾ D=2 (çŠ¶æ€ç»´åº¦), T=64 (åºåˆ—é•¿åº¦)

param_count = {
    "input_projection": 6 * 256 + 256,  # 1.6K
    "pos_encoding": 0,  # æ— å¯å­¦ä¹ å‚æ•°
    "time_embedding": (2*64) * 256 + 256,  # 33K
    "condition_encoder": (5*2) * 128 + 128,  # 1.4K
    
    "per_transformer_block": {
        "adaLN_1": 256 * 128 + 256 * 128,  # 65K (gamma å’Œ beta)
        "mha_qkv": 3 * 256 * 256,  # 195K
        "mha_out": 256 * 256,  # 65K
        "adaLN_2": 256 * 128 + 256 * 128,  # 65K
        "ffn_1": 256 * 1024 + 1024,  # 263K
        "ffn_2": 1024 * 256 + 256,  # 262K
        "total_per_block": "~918K",
    },
    
    "total_transformer": "918K * 6 layers = ~5.5M",
    
    "output_head": 256 * 6 + 6,  # 1.5K
}
```

#### AdaLN è¯¦è§£

AdaLN (Adaptive Layer Normalization) æ˜¯æœ¬æ¶æ„çš„å…³é”®åˆ›æ–°ï¼š

```python
# æ ‡å‡† LayerNorm
def layer_norm(x):
    # x: [B, T, hidden_dim]
    mean = x.mean(dim=-1, keepdim=True)  # [B, T, 1]
    std = x.std(dim=-1, keepdim=True)    # [B, T, 1]
    return (x - mean) / std

# AdaLN
def adaptive_layer_norm(x, cond_emb):
    # x: [B, T, hidden_dim]
    # cond_emb: [B, cond_dim]
    
    # ç”Ÿæˆç¼©æ”¾å’Œåç§»å‚æ•°
    gamma = linear_gamma(cond_emb)  # [B, hidden_dim]
    beta = linear_beta(cond_emb)    # [B, hidden_dim]
    
    # æ ‡å‡†å½’ä¸€åŒ–
    mean = x.mean(dim=-1, keepdim=True)
    std = x.std(dim=-1, keepdim=True)
    x_norm = (x - mean) / std  # [B, T, hidden_dim]
    
    # è‡ªé€‚åº”å˜æ¢ï¼ˆå¹¿æ’­ gamma å’Œ betaï¼‰
    gamma = gamma.unsqueeze(1)  # [B, 1, hidden_dim]
    beta = beta.unsqueeze(1)    # [B, 1, hidden_dim]
    
    return gamma * x_norm + beta  # [B, T, hidden_dim]

# ä¼˜ç‚¹ï¼š
# 1. æ—¶é—´å’Œæ¡ä»¶ç›¸å…³ï¼šgamma å’Œ beta ç”± cond_emb æ§åˆ¶
# 2. ä½ç½®æ— å…³ï¼šå¯¹åºåˆ—ä¸­çš„æ¯ä¸€æ­¥åº”ç”¨ç›¸åŒçš„ gamma/beta
# 3. å¢å¼ºæ¡ä»¶ä¿¡æ¯çš„å½±å“ï¼šç›´æ¥è°ƒèŠ‚å„å±‚çš„æ¿€æ´»
```

#### æ³¨æ„åŠ›æœºåˆ¶è¯¦è§£

```python
# Multi-Head Self-Attention

def multi_head_attention(x, num_heads=8):
    # x: [B, T, hidden_dim]
    B, T, D = x.shape
    head_dim = D // num_heads
    
    # 1. çº¿æ€§æŠ•å½±ç”Ÿæˆ Q, K, V
    Q = linear_q(x)  # [B, T, D]
    K = linear_k(x)  # [B, T, D]
    V = linear_v(x)  # [B, T, D]
    
    # 2. åˆ†å¤´
    # [B, T, D] â†’ [B, T, num_heads, head_dim] â†’ [B, num_heads, T, head_dim]
    Q = Q.view(B, T, num_heads, head_dim).transpose(1, 2)
    K = K.view(B, T, num_heads, head_dim).transpose(1, 2)
    V = V.view(B, T, num_heads, head_dim).transpose(1, 2)
    
    # 3. è®¡ç®—æ³¨æ„åŠ›
    scores = Q @ K.transpose(-2, -1) / sqrt(head_dim)  # [B, num_heads, T, T]
    attention = softmax(scores, dim=-1)  # [B, num_heads, T, T]
    
    # 4. åº”ç”¨åˆ°å€¼
    output = attention @ V  # [B, num_heads, T, head_dim]
    
    # 5. åˆå¹¶å¤šå¤´
    output = output.transpose(1, 2).contiguous()  # [B, T, num_heads, head_dim]
    output = output.view(B, T, D)  # [B, T, D]
    
    # 6. æœ€åçš„çº¿æ€§æŠ•å½±
    return linear_out(output)  # [B, T, D]

# ä¸ºä»€ä¹ˆåˆ†å¤´ï¼Ÿ
# 1. å…è®¸æ¨¡å‹åœ¨ä¸åŒçš„è¡¨ç¤ºå­ç©ºé—´ä¸­å…³æ³¨ä¸åŒç±»å‹çš„ä¿¡æ¯
# 2. 8 ä¸ªå¤´å„è‡ªå­¦ä¹ ä¸åŒçš„æ³¨æ„åŠ›æ¨¡å¼
# 3. å¢åŠ æ¨¡å‹å®¹é‡å’Œè¡¨è¾¾åŠ›
```

### 2.4 æ•°æ®æ ¼å¼è¯´æ˜

#### è¾“å…¥æ•°æ®æ ¼å¼

```python
# æ–‡ä»¶æ ¼å¼: .npz, .npy, .h5, .pkl
{
    'positions': np.ndarray,      # [N, T, D] ä½ç½®è½¨è¿¹
    'velocities': np.ndarray,     # [N, T, D] é€Ÿåº¦è½¨è¿¹ (å¯é€‰)
    'accelerations': np.ndarray,  # [N, T, D] åŠ é€Ÿåº¦è½¨è¿¹ (å¯é€‰)
}

# å¦‚æœæœªæä¾› velocities/accelerationsï¼Œä¼šè‡ªåŠ¨ä» positions è®¡ç®—
```

#### æ¨¡å‹è¾“å…¥æ ¼å¼

```python
# è®­ç»ƒæ—¶
{
    'x_t': torch.Tensor,        # [B, T, 6] æ’å€¼çŠ¶æ€
    't': torch.Tensor,          # [B] æµæ—¶é—´
    'start_pos': torch.Tensor,  # [B, D] èµ·å§‹ä½ç½®
    'goal_pos': torch.Tensor,   # [B, D] ç›®æ ‡ä½ç½®
    'start_vel': torch.Tensor,  # [B, D] èµ·å§‹é€Ÿåº¦ (å¯é€‰)
}

# æ¨ç†æ—¶
{
    'x_t': torch.Tensor,        # [B, T, 6] å½“å‰çŠ¶æ€
    't': torch.Tensor,         # [B] å½“å‰æ—¶é—´
    'start_pos': torch.Tensor, # [B, D] èµ·å§‹ä½ç½®
    'goal_pos': torch.Tensor,  # [B, D] ç›®æ ‡ä½ç½®
    'start_vel': torch.Tensor, # [B, D] èµ·å§‹é€Ÿåº¦ (å¯é€‰)
}
```

#### æ¨¡å‹è¾“å‡ºæ ¼å¼

```python
{
    'output': torch.Tensor,  # [B, T, 6] é¢„æµ‹å‘é‡åœº
    # åˆ†è§£ä¸º:
    # - u_pred: [B, T, D] ä½ç½®é€Ÿåº¦åœº
    # - v_pred: [B, T, D] é€Ÿåº¦åŠ é€Ÿåº¦åœº
    # - w_pred: [B, T, D] åŠ é€Ÿåº¦æ€¥åŠ¨åœº
}
```

#### å®Œæ•´æ¨¡å‹å‰å‘ä¼ æ’­å¼ é‡ä¿¡æ¯æµ (Base é…ç½®)

**å‚æ•°è®¾å®š**ï¼šB=32, T=64, D=2, hidden_dim=256, num_heads=8, num_layers=6

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               æ¨¡å‹å‰å‘ä¼ æ’­ä¸­çš„å¼ é‡ç»´åº¦å˜åŒ– (Base Model)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ã€é˜¶æ®µ 0ã€‘è¾“å…¥å¤„ç†
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                             â”‚
â”‚  è¾“å…¥æ¡ä»¶å¼ é‡:                                              â”‚
â”‚  â”œâ”€ x_t [32, 64, 6]             â† æ‹¼æ¥çš„çŠ¶æ€å‘é‡          â”‚
â”‚  â”œâ”€ t [32]                       â† æµæ—¶é—´æ ‡é‡              â”‚
â”‚  â”œâ”€ start_pos [32, 2]           â† èµ·å§‹ä½ç½®                â”‚
â”‚  â”œâ”€ goal_pos [32, 2]            â† ç›®æ ‡ä½ç½®                â”‚
â”‚  â””â”€ start_vel [32, 2]           â† èµ·å§‹é€Ÿåº¦                â”‚
â”‚                                                             â”‚
â”‚  â”œâ”€ è¾“å…¥æŠ•å½±:                                               â”‚
â”‚  â”‚  Linear(6, 256)                                          â”‚
â”‚  â”‚  [32, 64, 6] â†’ [32, 64, 256]                            â”‚
â”‚  â”‚  x_embed                                                 â”‚
â”‚  â”‚                                                           â”‚
â”‚  â”œâ”€ ä½ç½®ç¼–ç :                                               â”‚
â”‚  â”‚  PE [64, 256]                                            â”‚
â”‚  â”‚  x_embed = x_embed + PE  (å¹¿æ’­: [32, 64, 256])          â”‚
â”‚  â”‚                                                           â”‚
â”‚  â”œâ”€ æ—¶é—´åµŒå…¥:                                               â”‚
â”‚  â”‚  Gaussian Fourier: t [32] â†’ [32, 128]                   â”‚
â”‚  â”‚  Linear(128, 128): [32, 128] â†’ [32, 128]                â”‚
â”‚  â”‚  time_emb [32, 128]                                      â”‚
â”‚  â”‚                                                           â”‚
â”‚  â”œâ”€ æ¡ä»¶ç¼–ç :                                               â”‚
â”‚  â”‚  concat([start_pos, goal_pos, start_vel]) [32, 6]      â”‚
â”‚  â”‚  Linear(6, 128): [32, 6] â†’ [32, 128]                    â”‚
â”‚  â”‚  cond_emb [32, 128]                                      â”‚
â”‚  â”‚                                                           â”‚
â”‚  â”œâ”€ æ¡ä»¶èåˆ:                                               â”‚
â”‚  â”‚  combined_cond = time_emb + cond_emb                     â”‚
â”‚  â”‚  combined_cond [32, 128]                                 â”‚
â”‚  â”‚                                                           â”‚
â”‚  â””â”€ é˜¶æ®µ 0 è¾“å‡º: [32, 64, 256]  combined_cond [32, 128]    â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ã€é˜¶æ®µ 1ã€‘ç¬¬ 1 ä¸ª Transformer Block (Block 0)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                             â”‚
â”‚  è¾“å…¥: x [32, 64, 256]  æ¡ä»¶: combined_cond [32, 128]     â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€ Sub-Block 1A: AdaLN                                    â”‚
â”‚  â”‚  â”œâ”€ Î³ = Linear_gamma(combined_cond) [32, 128] â†’ [32, 256]
â”‚  â”‚  â”œâ”€ Î² = Linear_beta(combined_cond) [32, 128] â†’ [32, 256] â”‚
â”‚  â”‚  â”œâ”€ x_norm = LayerNorm(x) [32, 64, 256]                â”‚
â”‚  â”‚  â”œâ”€ Î³.unsqueeze(1) [32, 1, 256] (å¹¿æ’­)                 â”‚
â”‚  â”‚  â”œâ”€ Î².unsqueeze(1) [32, 1, 256]                         â”‚
â”‚  â”‚  â””â”€ x_ada = Î³ * x_norm + Î² [32, 64, 256]               â”‚
â”‚  â”‚      è¾“å‡º: [32, 64, 256]                                 â”‚
â”‚  â”‚                                                           â”‚
â”‚  â”œâ”€ Sub-Block 1B: Multi-Head Self-Attention                â”‚
â”‚  â”‚  â”œâ”€ Linear_q(x_ada) [32, 64, 256]                       â”‚
â”‚  â”‚  â”œâ”€ Linear_k(x_ada) [32, 64, 256]                       â”‚
â”‚  â”‚  â”œâ”€ Linear_v(x_ada) [32, 64, 256]                       â”‚
â”‚  â”‚  â”‚                                                        â”‚
â”‚  â”‚  â”œâ”€ åˆ†å¤´:                                                 â”‚
â”‚  â”‚  â”‚  â”œâ”€ Q [32, 64, 256] â†’ [32, 8, 64, 32]              â”‚
â”‚  â”‚  â”‚  â”œâ”€ K [32, 64, 256] â†’ [32, 8, 64, 32]              â”‚
â”‚  â”‚  â”‚  â””â”€ V [32, 64, 256] â†’ [32, 8, 64, 32]              â”‚
â”‚  â”‚  â”‚                                                        â”‚
â”‚  â”‚  â”œâ”€ æ³¨æ„åŠ›è®¡ç®—:                                           â”‚
â”‚  â”‚  â”‚  â”œâ”€ scores = Q @ K^T / âˆš32                           â”‚
â”‚  â”‚  â”‚  â”‚  [32, 8, 64, 32] @ [32, 8, 32, 64] = [32, 8, 64, 64]
â”‚  â”‚  â”‚  â”œâ”€ weights = softmax(scores) [32, 8, 64, 64]       â”‚
â”‚  â”‚  â”‚  â””â”€ attn_out = weights @ V [32, 8, 64, 32]         â”‚
â”‚  â”‚  â”‚                                                        â”‚
â”‚  â”‚  â”œâ”€ åˆå¹¶å¤šå¤´:                                             â”‚
â”‚  â”‚  â”‚  â””â”€ [32, 8, 64, 32] â†’ [32, 64, 256]                 â”‚
â”‚  â”‚  â”‚                                                        â”‚
â”‚  â”‚  â”œâ”€ è¾“å‡ºæŠ•å½±:                                             â”‚
â”‚  â”‚  â”‚  â””â”€ Linear_out [32, 64, 256]                         â”‚
â”‚  â”‚  â”‚                                                        â”‚
â”‚  â”‚  â””â”€ æ®‹å·®è¿æ¥: x_attn = x_ada + attn_out [32, 64, 256] â”‚
â”‚  â”‚                                                           â”‚
â”‚  â”œâ”€ Sub-Block 1C: AdaLN                                    â”‚
â”‚  â”‚  â””â”€ åŒ Sub-Block 1A çš„è¿‡ç¨‹                              â”‚
â”‚  â”‚      è¾“å‡º: [32, 64, 256]                                 â”‚
â”‚  â”‚                                                           â”‚
â”‚  â””â”€ Sub-Block 1D: Feed-Forward Network                     â”‚
â”‚     â”œâ”€ Linear1(x_ada2) [32, 64, 256] â†’ [32, 64, 1024]     â”‚
â”‚     â”œâ”€ ReLU() [32, 64, 1024]                               â”‚
â”‚     â”œâ”€ Linear2() [32, 64, 1024] â†’ [32, 64, 256]           â”‚
â”‚     â”œâ”€ æ®‹å·®è¿æ¥: x_ffn = x_ada2 + ffn_out [32, 64, 256]   â”‚
â”‚     â””â”€ Block 0 è¾“å‡º: [32, 64, 256]                         â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ã€é˜¶æ®µ 2-6ã€‘Block 1, 2, 3, 4, 5 (è¿‡ç¨‹å®Œå…¨ç›¸åŒ)
â”‚
â”œâ”€ æ¯ä¸ª Block çš„è¾“å‡ºç»´åº¦: [32, 64, 256]
â”‚
â””â”€ Block 5 çš„è¾“å‡º: [32, 64, 256]

ã€é˜¶æ®µ 7ã€‘æœ€åçš„ AdaLN å’Œè¾“å‡ºå¤´
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                             â”‚
â”‚  è¾“å…¥: x [32, 64, 256]  æ¡ä»¶: combined_cond [32, 128]     â”‚
â”‚                                                             â”‚
â”‚  â”œâ”€ æœ€å AdaLN:                                             â”‚
â”‚  â”‚  â””â”€ åŒå‰é¢çš„ AdaLN è¿‡ç¨‹                                  â”‚
â”‚  â”‚      è¾“å‡º: [32, 64, 256]                                 â”‚
â”‚  â”‚                                                           â”‚
â”‚  â”œâ”€ è¾“å‡ºæŠ•å½±:                                               â”‚
â”‚  â”‚  Linear(256, 6)                                          â”‚
â”‚  â”‚  [32, 64, 256] â†’ [32, 64, 6]                            â”‚
â”‚  â”‚  raw_output [32, 64, 6]                                  â”‚
â”‚  â”‚                                                           â”‚
â”‚  â”œâ”€ åˆ†è§£å‘é‡åœº:                                             â”‚
â”‚  â”‚  â”œâ”€ u_pred = raw_output[..., :2]         [32, 64, 2]   â”‚
â”‚  â”‚  â”œâ”€ v_pred = raw_output[..., 2:4]        [32, 64, 2]   â”‚
â”‚  â”‚  â””â”€ w_pred = raw_output[..., 4:6]        [32, 64, 2]   â”‚
â”‚  â”‚                                                           â”‚
â”‚  â””â”€ æœ€ç»ˆè¾“å‡º:                                               â”‚
â”‚     {                                                        â”‚
â”‚         'output': [32, 64, 6],    # å®Œæ•´å‘é‡åœº              â”‚
â”‚         'u_pred': [32, 64, 2],    # ä½ç½®é€Ÿåº¦åœº              â”‚
â”‚         'v_pred': [32, 64, 2],    # åŠ é€Ÿåº¦åœº                â”‚
â”‚         'w_pred': [32, 64, 2],    # æ€¥åŠ¨åœº                  â”‚
â”‚     }                                                        â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ã€å†…å­˜å ç”¨ä¼°è®¡ã€‘(å‡è®¾ float32)

è¾“å…¥: 32 * 64 * 6 * 4 bytes = 49.2 KB
ä¸­é—´æ¿€æ´» (æœ€å¤§): 32 * 64 * 256 * 4 bytes = 2.1 MB
FFN ä¸­é—´: 32 * 64 * 1024 * 4 bytes = 8.4 MB
æ³¨æ„åŠ›çŸ©é˜µ: 32 * 8 * 64 * 64 * 4 bytes = 4.1 MB
æ€»è®¡æ¿€æ´»å†…å­˜: ~15-20 MB (ä¸è®¡æ¢¯åº¦)

ã€è®¡ç®—å¤æ‚åº¦ã€‘(FLOPs ä¼°è®¡, Base æ¨¡å‹)

è¾“å…¥æŠ•å½±: 32 * 64 * 6 * 256 = 3.1M FLOPs
ä½ç½®ç¼–ç : 0 (æŸ¥è¡¨)
æ—¶é—´åµŒå…¥: 32 * 256 * 256 â‰ˆ 2.1M FLOPs
æ¡ä»¶ç¼–ç : 32 * 10 * 128 â‰ˆ 40K FLOPs

æ¯ä¸ª Transformer Block:
  â”œâ”€ AdaLN (Ã—2): 32 * 64 * 256 * 2 â‰ˆ 1.0M FLOPs
  â”œâ”€ æ³¨æ„åŠ› (QKV): 32 * 64 * 256 * 3 â‰ˆ 1.6M FLOPs
  â”œâ”€ æ³¨æ„åŠ›è®¡ç®—: 32 * 8 * 64 * 64 * 32 â‰ˆ 1.0M FLOPs
  â”œâ”€ æ³¨æ„åŠ›è¾“å‡º: 32 * 8 * 64 * 64 * 32 â‰ˆ 1.0M FLOPs
  â”œâ”€ è¾“å‡ºæŠ•å½±: 32 * 64 * 256 * 256 â‰ˆ 0.1M FLOPs
  â””â”€ FFN: 32 * 64 * 256 * 4 * 2 â‰ˆ 4.2M FLOPs
  æ¯å—æ€»è®¡: ~10M FLOPs

6 ä¸ª Block: 10M * 6 = 60M FLOPs
è¾“å‡ºå¤´: 32 * 64 * 256 * 6 â‰ˆ 31K FLOPs
æ€»è®¡: ~67M FLOPs (å•æ¬¡å‰å‘ä¼ æ’­)
```

**å®é™…æ¨ç†æ—¶é—´** (RTX 3090 ä¸Šçš„å‚è€ƒå€¼):
- Base æ¨¡å‹, B=1: ~3-5 ms/forward pass
- Base æ¨¡å‹, B=32: ~30-50 ms/forward pass
- ä½¿ç”¨ TorchScript æˆ– ONNX å¯å†å¿« 1.5-2 å€

---

## ä¸‰ã€ä½¿ç”¨æ–¹æ¡ˆ

### 3.1 å¿«é€Ÿå¼€å§‹

#### å®‰è£…ä¾èµ–

```bash
# åˆ›å»ºè™šæ‹Ÿç¯å¢ƒ
python -m venv venv
source venv/bin/activate  # Linux/Mac
# æˆ–: venv\Scripts\activate  # Windows

# å®‰è£…ä¾èµ–
pip install -r requirements.txt
```

#### ä½¿ç”¨åˆæˆæ•°æ®è®­ç»ƒ

```bash
# åŸºç¡€è®­ç»ƒ
python train.py --synthetic --num_trajectories 5000 --epochs 50

# ä½¿ç”¨ä¸åŒè½¨è¿¹ç±»å‹
python train.py --synthetic --trajectory_type bezier --epochs 100
python train.py --synthetic --trajectory_type polynomial --epochs 100
python train.py --synthetic --trajectory_type sine --epochs 100
```

#### ä½¿ç”¨è‡ªå®šä¹‰æ•°æ®è®­ç»ƒ

```bash
# ä»æ–‡ä»¶åŠ è½½æ•°æ®
python train.py \
    --data_path /path/to/trajectories.npz \
    --epochs 100 \
    --batch_size 32 \
    --lr 1e-4

# è‡ªå®šä¹‰æ¨¡å‹é…ç½®
python train.py \
    --data_path /path/to/data.npz \
    --model_variant large \
    --hidden_dim 512 \
    --num_layers 8 \
    --lr 5e-5
```

#### ç”Ÿæˆè½¨è¿¹

```bash
# åŸºç¡€ç”Ÿæˆ
python inference.py \
    --checkpoint checkpoints/best_model.pt \
    --start 0,0 \
    --goal 2,2 \
    --visualize

# ç”Ÿæˆå¤šä¸ªæ ·æœ¬
python inference.py \
    --checkpoint checkpoints/best_model.pt \
    --start 0,0 \
    --goal 2,2 \
    --num_samples 10 \
    --output generated_trajectories.npz

# ä½¿ç”¨8æ­¥éå‡åŒ€è°ƒåº¦ (æ¨èï¼Œå¿«é€Ÿæ¨ç†)
python inference.py \
    --checkpoint checkpoints/best_model.pt \
    --start 0,0 \
    --goal 2,2 \
    --solver rk4 \
    --use_8step_schedule

# è‡ªå®šä¹‰ODEæ±‚è§£å™¨è®¾ç½®
python inference.py \
    --checkpoint checkpoints/best_model.pt \
    --start 0,0 \
    --goal 2,2 \
    --solver rk4 \
    --num_steps 50
```

### 3.2 Python API ä½¿ç”¨

#### è®­ç»ƒ API

```python
import torch
from cfm_flowmp.models import create_flowmp_transformer
from cfm_flowmp.training import CFMTrainer, TrainerConfig, FlowMatchingConfig
from cfm_flowmp.data import SyntheticTrajectoryDataset, create_dataloader

# 1. åˆ›å»ºæ¨¡å‹
model = create_flowmp_transformer(
    variant="base",      # "small", "base", "large"
    state_dim=2,         # çŠ¶æ€ç»´åº¦ (2D: x, y)
    max_seq_len=64,      # è½¨è¿¹é•¿åº¦
)

# 2. åˆ›å»ºæ•°æ®é›†
dataset = SyntheticTrajectoryDataset(
    num_trajectories=5000,
    seq_len=64,
    trajectory_type="bezier",
)

# 3. åˆ›å»ºæ•°æ®åŠ è½½å™¨
train_loader = create_dataloader(
    dataset,
    batch_size=64,
    shuffle=True,
    num_workers=4,
)

# 4. é…ç½®è®­ç»ƒ
flow_config = FlowMatchingConfig(
    state_dim=2,
    lambda_vel=1.0,      # é€Ÿåº¦åœºæŸå¤±æƒé‡
    lambda_acc=1.0,      # åŠ é€Ÿåº¦åœºæŸå¤±æƒé‡
    lambda_jerk=1.0,     # æ€¥åŠ¨åœºæŸå¤±æƒé‡
)

trainer_config = TrainerConfig(
    num_epochs=100,
    learning_rate=1e-4,
    device="cuda",
    use_amp=True,
    flow_config=flow_config,
)

# 5. åˆ›å»ºè®­ç»ƒå™¨å¹¶è®­ç»ƒ
trainer = CFMTrainer(
    model=model,
    config=trainer_config,
    train_dataloader=train_loader,
    val_dataloader=None,  # å¯é€‰éªŒè¯é›†
)

trainer.train()
```

#### æ¨ç† API

```python
import torch
from cfm_flowmp.models import create_flowmp_transformer
from cfm_flowmp.inference import TrajectoryGenerator, GeneratorConfig
from cfm_flowmp.inference.generator import create_8step_schedule

# 1. åŠ è½½æ¨¡å‹
model = create_flowmp_transformer(variant="base")
checkpoint = torch.load("checkpoints/best_model.pt")
model.load_state_dict(checkpoint['model_state_dict'])
model.eval()

# 2. åˆ›å»ºç”Ÿæˆå™¨ (æ¨èä½¿ç”¨8æ­¥éå‡åŒ€è°ƒåº¦)
gen_config = GeneratorConfig(
    solver_type="rk4",
    time_schedule=create_8step_schedule(),  # [0.0, 0.8, 0.85, 0.9, 0.92, 0.94, 0.96, 0.98, 1.0]
    use_bspline_smoothing=True,
    seq_len=64,
    state_dim=2,
)

generator = TrajectoryGenerator(model, gen_config)

# 3. ç”Ÿæˆè½¨è¿¹
start_pos = torch.tensor([[0.0, 0.0]])  # [1, 2]
goal_pos = torch.tensor([[2.0, 2.0]])  # [1, 2]

with torch.no_grad():
    result = generator.generate(
        start_pos=start_pos,
        goal_pos=goal_pos,
        num_samples=5,  # ç”Ÿæˆ5ä¸ªæ ·æœ¬
    )

# 4. è·å–ç»“æœ
positions = result['positions']      # [5, 64, 2]
velocities = result['velocities']    # [5, 64, 2]
accelerations = result['accelerations']  # [5, 64, 2]
```

#### è‡ªå®šä¹‰æ•°æ®åŠ è½½

```python
from cfm_flowmp.data import TrajectoryDataset, create_dataloader

# ä»æ–‡ä»¶åŠ è½½
dataset = TrajectoryDataset(
    data_path="trajectories.npz",
    normalize=True,  # è‡ªåŠ¨å½’ä¸€åŒ–
    compute_derivatives=True,  # è‡ªåŠ¨è®¡ç®—å¯¼æ•°
)

# æˆ–ç›´æ¥ä¼ å…¥æ•°ç»„
import numpy as np
positions = np.random.randn(1000, 64, 2)  # [N, T, D]

dataset = TrajectoryDataset(
    positions=positions,
    normalize=True,
)

# åˆ›å»ºæ•°æ®åŠ è½½å™¨
train_loader = create_dataloader(
    dataset,
    batch_size=64,
    shuffle=True,
)
```

#### L2å±‚ä¸‰å±‚æ¶æ„é›†æˆ API

```python
import torch
from cfm_flowmp.models import create_l2_safety_cfm, L2Config

# ==================== L2å±‚é…ç½®ä¸åˆ›å»º ====================

# 1. åˆ›å»ºL2å±‚æ¨¡å‹ï¼ˆä½¿ç”¨Transformeråç«¯ï¼‰
config = L2Config(
    model_type="transformer",           # æˆ– "unet1d"
    state_dim=2,                        # 2Då¹³é¢
    seq_len=64,                         # è½¨è¿¹é•¿åº¦
    cost_map_channels=4,                # ä»£ä»·åœ°å›¾é€šé“æ•°
    cost_map_size=64,                   # ä»£ä»·åœ°å›¾åˆ†è¾¨ç‡
    hidden_dim=256,                     # Transformeréšè—ç»´åº¦
    num_layers=8,                       # Transformerå±‚æ•°
    num_heads=8,                        # æ³¨æ„åŠ›å¤´æ•°
    cond_dim=256,                       # æ¡ä»¶å‘é‡ç»´åº¦
    use_cbf=False,                      # æ˜¯å¦ä½¿ç”¨CBFçº¦æŸ
    cbf_margin=0.1,                     # CBFå®‰å…¨ä½™é‡
)

model = create_l2_safety_cfm(config=config)
model.eval()  # æ¨ç†æ¨¡å¼

# ==================== ä»L3æ¥æ”¶è¾“å…¥ ====================

# L3å±‚è¾“å‡ºï¼šè¯­ä¹‰ä»£ä»·åœ°å›¾
cost_map = torch.rand(2, 4, 64, 64)  # [B=2, C=4, H=64, W=64]
# é€šé“å«ä¹‰ç¤ºä¾‹ï¼š
#   channel 0: éšœç¢ç‰©å ç”¨æ¦‚ç‡ [0, 1]
#   channel 1: å¯é€šè¡Œæ€§è¯„åˆ† [0, 1]
#   channel 2: é£é™©ç­‰çº§ [0, 1]
#   channel 3: è¯­ä¹‰æ ‡ç­¾ç¼–ç 

# æœºå™¨äººå½“å‰çŠ¶æ€ [position_x, position_y, velocity_x, velocity_y, accel_x, accel_y]
x_curr = torch.tensor([
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # æ ·æœ¬1ï¼šé™æ­¢çŠ¶æ€
    [1.0, 1.0, 0.5, 0.3, 0.0, 0.0],  # æ ·æœ¬2ï¼šè¿åŠ¨çŠ¶æ€
])  # [B=2, 6]

# ç›®æ ‡çŠ¶æ€ [position_x, position_y, velocity_x, velocity_y]
x_goal = torch.tensor([
    [5.0, 5.0, 0.0, 0.0],  # æ ·æœ¬1ç›®æ ‡
    [6.0, 4.0, 0.0, 0.0],  # æ ·æœ¬2ç›®æ ‡
])  # [B=2, 4]

# æ§åˆ¶é£æ ¼æƒé‡ [w_safety, w_energy, w_smooth]
w_style = torch.tensor([
    [0.7, 0.1, 0.2],  # æ ·æœ¬1ï¼šä¿å®ˆæ¨¡å¼ï¼ˆå®‰å…¨ä¼˜å…ˆï¼‰
    [0.2, 0.5, 0.3],  # æ ·æœ¬2ï¼šé«˜æ•ˆæ¨¡å¼ï¼ˆæ•ˆç‡ä¼˜å…ˆï¼‰
])  # [B=2, 3]

# ==================== L2å±‚ç”Ÿæˆè½¨è¿¹é”šç‚¹ ====================

with torch.no_grad():
    result = model.generate_trajectory_anchors(
        cost_map=cost_map,
        x_curr=x_curr,
        x_goal=x_goal,
        w_style=w_style,
        num_samples=64,  # æ¯ä¸ªæ ·æœ¬ç”Ÿæˆ64æ¡å€™é€‰è½¨è¿¹
    )

# ==================== è¾“å‡ºç»™L1 MPPI ====================

# result æ˜¯ä¸€ä¸ªå­—å…¸ï¼ŒåŒ…å«ï¼š
trajectories = result['trajectories']      # [BÃ—N, T, 2] = [128, 64, 2]
velocities = result['velocities']          # [BÃ—N, T, 2] = [128, 64, 2]
accelerations = result['accelerations']    # [BÃ—N, T, 2] = [128, 64, 2]

# å¯¹äºæ ·æœ¬0ï¼Œè·å–å…¶64æ¡å€™é€‰è½¨è¿¹
sample_0_trajectories = trajectories[:64]   # [64, 64, 2]
sample_0_velocities = velocities[:64]       # [64, 64, 2]
sample_0_accelerations = accelerations[:64] # [64, 64, 2]

print(f"ä¸ºæ ·æœ¬0ç”Ÿæˆäº† {len(sample_0_trajectories)} æ¡è½¨è¿¹é”šç‚¹")
print(f"æ¯æ¡è½¨è¿¹åŒ…å« {sample_0_trajectories.shape[1]} ä¸ªæ—¶é—´æ­¥")

# ==================== L1 MPPIä½¿ç”¨ç¤ºä¾‹ (ä¼ªä»£ç ) ====================

# MPPIé€‰æ‹©æœ€ä¼˜è½¨è¿¹é”šç‚¹ä½œä¸ºwarm-start
# mppi_optimizer.warm_start(sample_0_trajectories, sample_0_velocities)
# optimal_control = mppi_optimizer.optimize(current_state=x_curr[0])

# ==================== ä¸åŒæ§åˆ¶é£æ ¼æ•ˆæœå¯¹æ¯” ====================

# ä¿å®ˆæ¨¡å¼ï¼šw_style = [0.7, 0.1, 0.2]
# - è¿œç¦»éšœç¢ç‰©
# - ä¿å®ˆè·¯å¾„é€‰æ‹©
# - è¾ƒä½é€Ÿåº¦

# å¹³è¡¡æ¨¡å¼ï¼šw_style = [0.4, 0.3, 0.3]
# - ç»¼åˆè€ƒè™‘å®‰å…¨ã€æ•ˆç‡ã€å¹³æ»‘
# - é€‚ç”¨äºå¤§å¤šæ•°åœºæ™¯

# é«˜æ•ˆæ¨¡å¼ï¼šw_style = [0.2, 0.5, 0.3]
# - æœ€çŸ­è·¯å¾„
# - è¾ƒé«˜é€Ÿåº¦
# - æ¿€è¿›è¡Œä¸º
```

#### L2å±‚è®­ç»ƒ API

```python
import torch
from torch.utils.data import Dataset, DataLoader
from cfm_flowmp.models import create_l2_safety_cfm, L2Config
from cfm_flowmp.training import FlowMatchingConfig, CFMTrainer, TrainerConfig

# ==================== è‡ªå®šä¹‰L2æ•°æ®é›† ====================

class L2TrajectoryDataset(Dataset):
    """L2å±‚è®­ç»ƒæ•°æ®é›†ï¼ŒåŒ…å«ä»£ä»·åœ°å›¾"""
    
    def __init__(self, data_path):
        data = torch.load(data_path)
        
        # å¿…éœ€å­—æ®µ
        self.trajectories = data['trajectories']      # [N, T, 2]
        self.velocities = data['velocities']          # [N, T, 2]
        self.accelerations = data['accelerations']    # [N, T, 2]
        self.cost_maps = data['cost_maps']            # [N, C, H, W]
        self.start_states = data['start_states']      # [N, 6]
        self.goal_states = data['goal_states']        # [N, 4]
        self.style_weights = data['style_weights']    # [N, 3]
        
    def __len__(self):
        return len(self.trajectories)
    
    def __getitem__(self, idx):
        return {
            'positions': self.trajectories[idx],      # [T, 2]
            'velocities': self.velocities[idx],       # [T, 2]
            'accelerations': self.accelerations[idx], # [T, 2]
            'cost_map': self.cost_maps[idx],          # [C, H, W]
            'start_state': self.start_states[idx],    # [6]
            'goal_state': self.goal_states[idx],      # [4]
            'style_weight': self.style_weights[idx],  # [3]
        }

# ==================== åˆ›å»ºæ•°æ®åŠ è½½å™¨ ====================

dataset = L2TrajectoryDataset('l2_training_data.pt')

train_loader = DataLoader(
    dataset,
    batch_size=32,
    shuffle=True,
    num_workers=4,
    pin_memory=True,
)

# ==================== åˆ›å»ºL2æ¨¡å‹ ====================

config = L2Config(
    model_type="transformer",
    state_dim=2,
    seq_len=64,
    cost_map_channels=4,
    cost_map_size=64,
)

model = create_l2_safety_cfm(config=config)

# ==================== é…ç½®è®­ç»ƒå™¨ ====================

flow_config = FlowMatchingConfig(
    state_dim=2,
    lambda_vel=1.0,
    lambda_acc=1.0,
    lambda_jerk=1.0,
)

trainer_config = TrainerConfig(
    num_epochs=100,
    learning_rate=1e-4,
    device="cuda",
    use_amp=True,
    flow_config=flow_config,
)

# ==================== è®­ç»ƒL2å±‚ ====================

# æ³¨æ„ï¼šéœ€è¦è‡ªå®šä¹‰è®­ç»ƒå¾ªç¯ä»¥å¤„ç†cost_mapè¾“å…¥
# æˆ–æ‰©å±•CFMTrainerä»¥æ”¯æŒL2å±‚çš„ç‰¹æ®Šè¾“å…¥

for epoch in range(trainer_config.num_epochs):
    model.train()
    
    for batch in train_loader:
        # æå–æ‰¹æ¬¡æ•°æ®
        positions = batch['positions']          # [B, T, 2]
        velocities = batch['velocities']        # [B, T, 2]
        accelerations = batch['accelerations']  # [B, T, 2]
        cost_map = batch['cost_map']            # [B, C, H, W]
        start_state = batch['start_state']      # [B, 6]
        goal_state = batch['goal_state']        # [B, 4]
        style_weight = batch['style_weight']    # [B, 3]
        
        # L2å±‚å‰å‘ä¼ æ’­ï¼ˆè®­ç»ƒæ¨¡å¼ï¼‰
        loss_dict = model.forward(
            trajectories=positions,
            velocities=velocities,
            accelerations=accelerations,
            cost_map=cost_map,
            x_curr=start_state,
            x_goal=goal_state,
            w_style=style_weight,
        )
        
        # åå‘ä¼ æ’­
        loss = loss_dict['total_loss']
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
        
        print(f"Epoch {epoch}, Loss: {loss.item():.4f}")

# ==================== ä¿å­˜æ¨¡å‹ ====================

torch.save({
    'model_state_dict': model.state_dict(),
    'config': config,
}, 'l2_safety_cfm.pt')
```

### 3.3 å®Œæ•´ç¤ºä¾‹

å‚è€ƒ `example.py` æ–‡ä»¶ï¼Œå®ƒå±•ç¤ºäº†å®Œæ•´çš„è®­ç»ƒå’Œæ¨ç†æµç¨‹ï¼š

```bash
python example.py
```

è¯¥ç¤ºä¾‹åŒ…æ‹¬ï¼š
1. åˆ›å»ºåˆæˆæ•°æ®é›†
2. åˆ›å»ºæ¨¡å‹
3. è®­ç»ƒæ¨¡å‹ï¼ˆçŸ­æ—¶é—´æ¼”ç¤ºï¼‰
4. ç”Ÿæˆè½¨è¿¹
5. å¯è§†åŒ–ç»“æœ

### 3.4 é«˜çº§ç”¨æ³•

#### è‡ªå®šä¹‰æ—¶é—´è°ƒåº¦

```python
from cfm_flowmp.inference import GeneratorConfig

# è‡ªå®šä¹‰éå‡åŒ€æ—¶é—´è°ƒåº¦
custom_schedule = [0.0, 0.5, 0.75, 0.9, 0.95, 0.98, 1.0]

gen_config = GeneratorConfig(
    solver_type="rk4",
    time_schedule=custom_schedule,
    use_bspline_smoothing=True,
)
```

#### å¸¦å¼•å¯¼çš„ç”Ÿæˆ

```python
# å®šä¹‰éšœç¢ç‰©å‡½æ•°
def obstacle_fn(positions):
    """è¿”å›éšœç¢ç‰©æˆæœ¬ï¼ˆè¶Šå°è¶Šå¥½ï¼‰"""
    # ç¤ºä¾‹: é¿å…ä¸­å¿ƒåŒºåŸŸ
    center = torch.tensor([1.0, 1.0])
    dist = (positions - center).norm(dim=-1)
    cost = torch.exp(-dist)  # è·ç¦»ä¸­å¿ƒè¶Šè¿‘ï¼Œæˆæœ¬è¶Šé«˜
    return cost.sum()

# ä½¿ç”¨å¼•å¯¼ç”Ÿæˆ
result = generator.generate_with_guidance(
    start_pos=start_pos,
    goal_pos=goal_pos,
    guidance_scale=2.0,  # å¼•å¯¼å¼ºåº¦
    obstacle_fn=obstacle_fn,
)
```

#### æ‰¹é‡ç”Ÿæˆ

```python
# å‡†å¤‡å¤šä¸ªæ¡ä»¶
conditions = [
    {'start_pos': torch.tensor([0.0, 0.0]), 'goal_pos': torch.tensor([2.0, 2.0])},
    {'start_pos': torch.tensor([1.0, 0.0]), 'goal_pos': torch.tensor([1.0, 2.0])},
    {'start_pos': torch.tensor([0.0, 1.0]), 'goal_pos': torch.tensor([2.0, 1.0])},
]

# æ‰¹é‡ç”Ÿæˆ
results = generator.generate_batch(
    conditions,
    batch_size=32,
)
```

---

## å››ã€å…³é”®å‚æ•°è¯´æ˜

### 4.1 æ¨¡å‹å˜ä½“

| å˜ä½“ | Hidden Dim | Layers | Heads | å‚æ•°é‡ |
|------|-----------|--------|-------|--------|
| small | 128 | 4 | 4 | ~3M |
| base | 256 | 6 | 8 | ~12M |
| large | 512 | 8 | 16 | ~50M |

### 4.2 è®­ç»ƒè¶…å‚æ•°

| å‚æ•° | é»˜è®¤å€¼ | è¯´æ˜ |
|------|--------|------|
| learning_rate | 1e-4 | Adam å­¦ä¹ ç‡ |
| weight_decay | 0.01 | L2 æ­£åˆ™åŒ– |
| warmup_steps | 1000 | å­¦ä¹ ç‡é¢„çƒ­æ­¥æ•° |
| lambda_vel | 1.0 | é€Ÿåº¦åœºæŸå¤±æƒé‡ |
| lambda_acc | 1.0 | åŠ é€Ÿåº¦åœºæŸå¤±æƒé‡ |
| lambda_jerk | 1.0 | æ€¥åŠ¨åœºæŸå¤±æƒé‡ |
| batch_size | 64 | æ‰¹æ¬¡å¤§å° |
| gradient_accumulation | 1 | æ¢¯åº¦ç´¯ç§¯æ­¥æ•° |

### 4.3 æ¨ç†è¶…å‚æ•°

| å‚æ•° | é»˜è®¤å€¼ | è¯´æ˜ |
|------|--------|------|
| solver_type | "rk4" | ODE æ±‚è§£å™¨ç±»å‹ ("euler", "midpoint", "rk4", "rk45") |
| num_steps | 20 | å‡åŒ€æ—¶é—´æ­¥æ•° |
| time_schedule | None | è‡ªå®šä¹‰æ—¶é—´è°ƒåº¦ (è¦†ç›– num_steps) |
| use_bspline_smoothing | True | æ˜¯å¦ä½¿ç”¨ B-spline å¹³æ»‘ |
| bspline_degree | 3 | B-spline åº¦æ•° |

### 4.4 æ¨èé…ç½®

#### å¿«é€Ÿè®­ç»ƒï¼ˆå¼€å‘/æµ‹è¯•ï¼‰
```python
variant = "small"
epochs = 10
batch_size = 32
lr = 1e-3
```

#### æ ‡å‡†è®­ç»ƒï¼ˆç”Ÿäº§ï¼‰
```python
variant = "base"
epochs = 100
batch_size = 64
lr = 1e-4
```

#### é«˜ç²¾åº¦è®­ç»ƒï¼ˆç ”ç©¶ï¼‰
```python
variant = "large"
epochs = 200
batch_size = 32
lr = 5e-5
use_amp = False
```

---

## å››ã€å¸¸è§é—®é¢˜ä¸ä¼˜åŒ–å»ºè®®

### 4.1 è®­ç»ƒå¸¸è§é—®é¢˜

#### Q: è®­ç»ƒæŸå¤±ä¸æ”¶æ•›æ€ä¹ˆåŠï¼Ÿ
**A:** æ£€æŸ¥ä»¥ä¸‹å‡ ç‚¹ï¼š
1. å­¦ä¹ ç‡æ˜¯å¦è¿‡é«˜ï¼šå»ºè®®ä» 1e-4 å¼€å§‹
2. æ•°æ®æ˜¯å¦å·²å½’ä¸€åŒ–ï¼šä½¿ç”¨ `normalize=True`
3. æ¢¯åº¦æ˜¯å¦çˆ†ç‚¸ï¼šä½¿ç”¨æ¢¯åº¦è£å‰ª `max_grad_norm=1.0`
4. æ‰¹æ¬¡å¤§å°ï¼šè¾ƒå¤§çš„æ‰¹æ¬¡ (64-128) é€šå¸¸æ›´ç¨³å®š

#### Q: æ˜¾å­˜ä¸è¶³æ€ä¹ˆåŠï¼Ÿ
**A:** å°è¯•ä»¥ä¸‹æ–¹æ¡ˆï¼š
1. å‡å°‘æ‰¹æ¬¡å¤§å°ï¼š`batch_size=32` æˆ–æ›´å°
2. ä½¿ç”¨æ¢¯åº¦ç´¯ç§¯ï¼š`gradient_accumulation_steps=4`
3. å¯ç”¨æ··åˆç²¾åº¦ï¼š`use_amp=True`
4. ä½¿ç”¨æ›´å°çš„æ¨¡å‹ï¼š`variant="small"`

#### Q: è®­ç»ƒé€Ÿåº¦å¤ªæ…¢æ€ä¹ˆåŠï¼Ÿ
**A:** ä¼˜åŒ–å»ºè®®ï¼š
1. å¢åŠ  `num_workers`ï¼šå–å†³äº CPU æ ¸å¿ƒæ•°
2. ä½¿ç”¨æ›´å¤§çš„æ‰¹æ¬¡ï¼š`batch_size=128` ï¼ˆæ˜¾å­˜å…è®¸ï¼‰
3. å¯ç”¨æ··åˆç²¾åº¦ï¼šè‡ªåŠ¨å¿« 1.5-2 å€
4. ä½¿ç”¨åˆ†å¸ƒå¼è®­ç»ƒï¼šå¤š GPU å¹¶è¡Œ

### 4.2 æ¨ç†å¸¸è§é—®é¢˜

#### Q: ç”Ÿæˆçš„è½¨è¿¹ä¸å…‰æ»‘æ€ä¹ˆåŠï¼Ÿ
**A:** 
1. ç¡®ä¿å¯ç”¨ B-spline å¹³æ»‘ï¼š`use_bspline_smoothing=True`
2. å¢åŠ  ODE æ­¥æ•°ï¼š`num_steps=50` ï¼ˆæ›´ç²¾ç»†çš„ç§¯åˆ†ï¼‰
3. ä½¿ç”¨éå‡åŒ€è°ƒåº¦ï¼š`use_8step_schedule=True` ï¼ˆæ¨èï¼‰

#### Q: æ¨ç†é€Ÿåº¦è¿‡æ…¢æ€ä¹ˆåŠï¼Ÿ
**A:**
1. ä½¿ç”¨ 8 æ­¥éå‡åŒ€è°ƒåº¦ï¼šå¿« 3-5 å€
2. å‡å°‘åºåˆ—é•¿åº¦ï¼š`seq_len=32`
3. ä½¿ç”¨ TorchScript ç¼–è¯‘æ¨¡å‹
4. å¯ç”¨ ONNX æ¨ç†åŠ é€Ÿ

#### Q: ç”Ÿæˆçš„è½¨è¿¹ä¸æ¡ä»¶ä¸ç¬¦æ€ä¹ˆåŠï¼Ÿ
**A:**
1. æ£€æŸ¥è¾“å…¥æ¡ä»¶æ ¼å¼æ˜¯å¦æ­£ç¡®
2. å¢åŠ æ¡ä»¶æƒé‡ï¼ˆå¦‚æœæ”¯æŒï¼‰
3. ä½¿ç”¨æ›´å¼ºå¤§çš„æ¨¡å‹ï¼š`variant="large"`
4. å¢åŠ è®­ç»ƒæ—¶é—´å’Œæ•°æ®é‡

### 4.3 æ€§èƒ½ä¼˜åŒ–å»ºè®®

#### è®­ç»ƒä¼˜åŒ–
| æ–¹é¢ | æ–¹æ³• | é¢„æœŸæ”¶ç›Š |
|------|------|---------|
| é€Ÿåº¦ | æ··åˆç²¾åº¦ + æ¢¯åº¦ç´¯ç§¯ | 1.5-2 å€ |
| é€Ÿåº¦ | åˆ†å¸ƒå¼è®­ç»ƒ (2 GPU) | ~1.8 å€ |
| æ˜¾å­˜ | æ¢¯åº¦ç´¯ç§¯ | å…è®¸æ›´å¤§æ‰¹æ¬¡ |
| ç²¾åº¦ | æ›´å¤§çš„æ¨¡å‹ | +2-3% æ€§èƒ½ |
| ç¨³å®šæ€§ | é¢„çƒ­å­¦ä¹ ç‡ | æ›´å¥½çš„æ”¶æ•› |

#### æ¨ç†ä¼˜åŒ–
| æ–¹æ¡ˆ | æ–¹æ³• | é€Ÿåº¦æå‡ | è´¨é‡æŸå¤± |
|------|------|---------|---------|
| å¿«é€Ÿ | 8æ­¥éå‡åŒ€è°ƒåº¦ | **3-5 å€** | <1% |
| è¾ƒå¿« | 20æ­¥å‡åŒ€è°ƒåº¦ | 1 å€ | 0% |
| ç²¾ç¡® | 50æ­¥å‡åŒ€è°ƒåº¦ | -2.5 å€ | +0.5% |

### 4.4 è°ƒè¯•æŠ€å·§

```python
# 1. éªŒè¯æ•°æ®æ ¼å¼
positions.shape  # åº”ä¸º [N, T, D]
assert positions.min() >= -10 and positions.max() <= 10  # åˆç†èŒƒå›´

# 2. æ£€æŸ¥æ¢¯åº¦æµåŠ¨
for name, param in model.named_parameters():
    if param.grad is None:
        print(f"æ— æ¢¯åº¦: {name}")

# 3. ç›‘è§†æŸå¤±
if loss.isnan() or loss.isinf():
    print("æ£€æµ‹åˆ°å¼‚å¸¸æŸå¤±ï¼")
    
# 4. å¯è§†åŒ–è½¨è¿¹
import matplotlib.pyplot as plt
plt.plot(positions[0, :, 0], positions[0, :, 1])
plt.show()
```

---

## äº”ã€æ‰©å±•åŠŸèƒ½

### 5.0 æ•°æ®é›†ç”Ÿæˆä¸ L2 è®­ç»ƒ/éªŒè¯ï¼ˆå‚ç…§ flow_mp-mainï¼‰

**æ•°æ®ç”Ÿæˆ**ï¼šä½¿ç”¨ B-spline ç”Ÿæˆ 2D è½¨è¿¹ï¼ˆpos/vel/accï¼‰å¹¶ç”Ÿæˆ cost_mapï¼Œä¿å­˜ä¸º `.npz`ã€‚

```bash
# ç”Ÿæˆæ•°æ®ï¼ˆè¾“å‡ºåˆ° traj_data/cfm_env/data.npzï¼‰
python -m cfm_flowmp.scripts.generate_data.generate_env_trajs_cfm \
  --output_dir traj_data/cfm_env --num_trajs 500 --seq_len 64 --map_size 64
```

**DataLoader**ï¼š`cfm_flowmp.data` æä¾› `FlowMPEnvDataset`ï¼ˆä» .npz åŠ è½½ï¼‰ä¸ `create_l2_dataloaders`ã€‚

```python
from cfm_flowmp.data import FlowMPEnvDataset, create_l2_dataloaders

# æ–¹å¼ä¸€ï¼šç›´æ¥ä½¿ç”¨ç”Ÿæˆæ•°æ®
train_loader, val_loader = create_l2_dataloaders(
    data_source="generated",
    data_dir="traj_data/cfm_env",
    batch_size=32,
    train_ratio=0.9,
    seed=42,
)

# æ–¹å¼äºŒï¼šMock æ•°æ®ï¼ˆæ— éœ€é¢„ç”Ÿæˆï¼‰
train_loader, val_loader = create_l2_dataloaders(
    data_source="mock",
    num_train=5000,
    num_val=500,
    batch_size=32,
    map_size=64,
    seq_len=64,
    style_mode="random",
)
```

**è®­ç»ƒ**ï¼š`train_l2_mock.py` æ”¯æŒ `--data_source mock|generated` ä¸ `--data_dir`ã€‚

```bash
# ä½¿ç”¨ Mock æ•°æ®è®­ç»ƒ
python train_l2_mock.py --num_samples 5000 --epochs 100 --batch_size 32

# ä½¿ç”¨ç”Ÿæˆæ•°æ®è®­ç»ƒ
python train_l2_mock.py --data_source generated --data_dir traj_data/cfm_env --epochs 100
```

**éªŒè¯**ï¼š`validate_l2.py` æ”¯æŒå‡ ä½•çº¦æŸä¸é£æ ¼å¯æ§æ€§æµ‹è¯•ï¼›å¯é€‰ä½¿ç”¨ç”Ÿæˆæ•°æ®ä¸­çš„ cost_mapã€‚

```bash
python validate_l2.py --checkpoint checkpoints_l2/best_model.pt --test_type all
python validate_l2.py --checkpoint checkpoints_l2/best_model.pt --data_dir traj_data/cfm_env --save_plots
```

### 5.1 è‡ªå®šä¹‰è½¨è¿¹æ•°æ®é›†

```python
from cfm_flowmp.data import TrajectoryDataset

# åˆ›å»ºè‡ªå®šä¹‰æ•°æ®é›†
class CustomTrajectoryDataset(TrajectoryDataset):
    def __getitem__(self, idx):
        # è·å–æ•°æ®
        pos = self.positions[idx]
        
        # è‡ªå®šä¹‰é¢„å¤„ç†
        pos = self.my_custom_preprocessing(pos)
        
        # è¿”å›æ ‡å‡†æ ¼å¼
        return {
            'positions': pos,
            'velocities': self.velocities[idx],
            'start_pos': pos[0],
            'goal_pos': pos[-1],
        }
    
    def my_custom_preprocessing(self, pos):
        # è‡ªå®šä¹‰æ•°æ®å¢å¼ºã€å˜æ¢ç­‰
        return pos
```

### 5.2 è‡ªå®šä¹‰æŸå¤±å‡½æ•°

```python
from cfm_flowmp.training import FlowMatchingLoss

class WeightedFlowMatchingLoss(FlowMatchingLoss):
    def forward(self, pred, target, weights=None):
        # åŸºç¡€æŸå¤±
        base_loss = super().forward(pred, target)
        
        # åŠ æƒæŸå¤±
        if weights is not None:
            weighted_loss = base_loss * weights
            return weighted_loss.mean()
        
        return base_loss
```

### 5.3 è‡ªå®šä¹‰æ¨¡å‹è¾“å‡ºå¤„ç†

```python
from cfm_flowmp.inference import TrajectoryGenerator

class CustomTrajectoryGenerator(TrajectoryGenerator):
    def generate(self, start_pos, goal_pos, **kwargs):
        # æ ‡å‡†ç”Ÿæˆ
        result = super().generate(start_pos, goal_pos, **kwargs)
        
        # è‡ªå®šä¹‰åå¤„ç†
        positions = result['positions']
        
        # ä¾‹: åº”ç”¨çº¦æŸ
        positions = self.apply_constraints(positions)
        
        result['positions'] = positions
        return result
    
    def apply_constraints(self, positions):
        # ç¡®ä¿è½¨è¿¹åœ¨æœ‰æ•ˆèŒƒå›´å†…
        positions = torch.clamp(positions, min=-10, max=10)
        return positions
```

---

## å…­ã€L2å±‚æ¶æ„æ€»ç»“

### 6.1 L2å±‚åœ¨ä¸‰å±‚æ¶æ„ä¸­çš„è§’è‰²

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å®Œæ•´ç³»ç»Ÿæ¶æ„ï¼šVLM-CFM-MPPIä¸‰å±‚è§„åˆ’                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

è¾“å…¥å±‚ï¼šä¼ æ„Ÿå™¨æ•°æ®
  â”œâ”€ RGB/æ·±åº¦å›¾åƒ
  â”œâ”€ æ¿€å…‰é›·è¾¾ç‚¹äº‘
  â”œâ”€ IMU/é‡Œç¨‹è®¡
  â””â”€ è¯­è¨€æŒ‡ä»¤ï¼ˆæ–‡æœ¬ï¼‰
        â”‚
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  L3: Vision-Language Model (è¯­ä¹‰ç†è§£å±‚)                        â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” â”‚
â”‚  åŠŸèƒ½ï¼šåœºæ™¯ç†è§£ã€è¯­ä¹‰åˆ†å‰²ã€é£é™©è¯„ä¼°                             â”‚
â”‚  è¾“å‡ºï¼šcost_map [B, C, H, W] - è¯­ä¹‰ä»£ä»·åœ°å›¾                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚ è¯­ä¹‰ä¿¡æ¯
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  L2: Safety-Embedded CFM (è½¨è¿¹ç”Ÿæˆå±‚) â˜… æœ¬é¡¹ç›®æ ¸å¿ƒ             â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” â”‚
â”‚                                                                 â”‚
â”‚  å­æ¨¡å—ï¼š                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ [1] CostMapEncoder                                      â”‚  â”‚
â”‚  â”‚     â””â”€ CNN: cost_map [B,C,H,W] â†’ e_map [B, 256]       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚          â”‚                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ [2] ConditionFusion                                     â”‚  â”‚
â”‚  â”‚     â””â”€ èåˆ: e_map + x_curr + x_goal + w_style         â”‚  â”‚
â”‚  â”‚     â””â”€ è¾“å‡º: condition [B, cond_dim]                   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚          â”‚                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ [3] FlowMPTransformer / FlowMPUNet1D                   â”‚  â”‚
â”‚  â”‚     â””â”€ æ¡ä»¶å‘é‡åœºé¢„æµ‹: v(x, t | condition)             â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚          â”‚                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ [4] ODE Solver (RK4)                                    â”‚  â”‚
â”‚  â”‚     â””â”€ æ±‚è§£: dx/dt = v(x, t) from noise â†’ trajectory  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚          â”‚                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ [5] Multi-Modal Sampling                                â”‚  â”‚
â”‚  â”‚     â””â”€ ç”Ÿæˆ N=64 æ¡å€™é€‰è½¨è¿¹ï¼ˆå¸¦å®Œæ•´åŠ¨åŠ›å­¦ï¼‰             â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                 â”‚
â”‚  è¾“å‡ºï¼štrajectory_anchors                                       â”‚
â”‚    â”œâ”€ trajectories [BÃ—64, T, 2]                                â”‚
â”‚    â”œâ”€ velocities [BÃ—64, T, 2]                                  â”‚
â”‚    â””â”€ accelerations [BÃ—64, T, 2]                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚ å¤šæ¨¡æ€è½¨è¿¹é”šç‚¹
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  L1: MPPI (å®æ—¶ä¼˜åŒ–æ§åˆ¶å±‚)                                      â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” â”‚
â”‚  åŠŸèƒ½ï¼šå±€éƒ¨é‡‡æ ·ä¼˜åŒ–ã€å®æ—¶æ§åˆ¶                                   â”‚
â”‚  è¾“å…¥ï¼šä»64æ¡é”šç‚¹ä¸­é€‰æ‹©/ç»„åˆ                                     â”‚
â”‚  è¾“å‡ºï¼šu_optimal - æœ€ä¼˜æ§åˆ¶åºåˆ—                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚ æ§åˆ¶æŒ‡ä»¤
        â†“
æ‰§è¡Œå±‚ï¼šæœºå™¨äººæ§åˆ¶å™¨
  â””â”€ ç”µæœº/èˆµæœºæ‰§è¡Œ
```

### 6.2 L2å±‚å…³é”®ç‰¹æ€§

#### å¤šæ¨¡æ€ç”Ÿæˆèƒ½åŠ›
```
å•ä¸ªæ¡ä»¶ â†’ 64æ¡ä¸åŒè½¨è¿¹
  â”œâ”€ æ¢ç´¢å¤šç§å¯è¡Œè·¯å¾„
  â”œâ”€ é€‚åº”ä¸åŒé£é™©åå¥½
  â”œâ”€ å¢å¼ºé²æ£’æ€§
  â””â”€ ä¸ºL1 MPPIæä¾›ä¸°å¯Œçš„warm-starté€‰é¡¹
```

#### æ§åˆ¶é£æ ¼è°ƒèŠ‚
```
w_style = [w_safety, w_energy, w_smooth]

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æƒé‡é…ç½®    â”‚  è¡Œä¸ºç‰¹å¾                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [0.7,0.1,0.2]â”‚ ä¿å®ˆæ¨¡å¼ï¼šè¿œç¦»éšœç¢ï¼Œä½é€Ÿï¼Œå®‰å…¨ä¼˜å…ˆ      â”‚
â”‚ [0.4,0.3,0.3]â”‚ å¹³è¡¡æ¨¡å¼ï¼šç»¼åˆè€ƒè™‘å®‰å…¨ã€æ•ˆç‡ã€èˆ’é€‚      â”‚
â”‚ [0.2,0.5,0.3]â”‚ é«˜æ•ˆæ¨¡å¼ï¼šæœ€çŸ­è·¯å¾„ï¼Œé«˜é€Ÿï¼Œæ•ˆç‡ä¼˜å…ˆ      â”‚
â”‚ [0.3,0.2,0.5]â”‚ èˆ’é€‚æ¨¡å¼ï¼šå¹³æ»‘è½¨è¿¹ï¼Œå‡å°‘æ€¥åŠ¨ï¼Œä¹˜å®¢èˆ’é€‚  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### å®Œæ•´åŠ¨åŠ›å­¦è¾“å‡º
```
æ¯æ¡è½¨è¿¹åŒ…å«ï¼š
  â”œâ”€ Position [T, 2]     - ä½ç½®è½¨è¿¹
  â”œâ”€ Velocity [T, 2]     - é€Ÿåº¦åˆ†å¸ƒï¼ˆä¸€é˜¶å¯¼æ•°ï¼‰
  â””â”€ Acceleration [T, 2] - åŠ é€Ÿåº¦åˆ†å¸ƒï¼ˆäºŒé˜¶å¯¼æ•°ï¼‰

ä¼˜åŠ¿ï¼š
  âœ“ MPPIå¯ç›´æ¥ä½¿ç”¨åŠ¨åŠ›å­¦ä¿¡æ¯
  âœ“ æ— éœ€æ•°å€¼å¾®åˆ†ï¼ˆé¿å…å™ªå£°ï¼‰
  âœ“ ç‰©ç†ä¸€è‡´æ€§ä¿è¯
  âœ“ ä¾¿äºåŠ¨åŠ›å­¦çº¦æŸæ£€æŸ¥
```

### 6.3 L2å±‚æ•°æ®æ¥å£è§„èŒƒ

#### è¾“å…¥æ¥å£ï¼ˆä»L3æ¥æ”¶ï¼‰

```python
# å¿…éœ€è¾“å…¥
cost_map: torch.Tensor      # [B, C, H, W] è¯­ä¹‰ä»£ä»·åœ°å›¾
  - dtype: torch.float32
  - å€¼èŒƒå›´: [0, 1] å½’ä¸€åŒ–
  - é€šé“å«ä¹‰:
    * channel 0: éšœç¢ç‰©å ç”¨æ¦‚ç‡
    * channel 1: å¯é€šè¡Œæ€§è¯„åˆ†
    * channel 2: é£é™©ç­‰çº§
    * channel 3+: å…¶ä»–è¯­ä¹‰ä¿¡æ¯

x_curr: torch.Tensor        # [B, 6] å½“å‰æœºå™¨äººçŠ¶æ€
  - [pos_x, pos_y, vel_x, vel_y, acc_x, acc_y]
  - å•ä½: [m, m, m/s, m/s, m/sÂ², m/sÂ²]

x_goal: torch.Tensor        # [B, 4] ç›®æ ‡çŠ¶æ€
  - [pos_x, pos_y, vel_x, vel_y]
  - å•ä½: [m, m, m/s, m/s]

w_style: torch.Tensor       # [B, 3] æ§åˆ¶é£æ ¼æƒé‡
  - [w_safety, w_energy, w_smooth]
  - å’Œä¸º1.0ï¼Œéè´Ÿ
```

#### è¾“å‡ºæ¥å£ï¼ˆä¼ ç»™L1ï¼‰

```python
# è¾“å‡ºå­—å…¸
result = {
    'trajectories': torch.Tensor,    # [BÃ—N, T, 2] ä½ç½®è½¨è¿¹
    'velocities': torch.Tensor,      # [BÃ—N, T, 2] é€Ÿåº¦è½¨è¿¹
    'accelerations': torch.Tensor,   # [BÃ—N, T, 2] åŠ é€Ÿåº¦è½¨è¿¹
}

# å‚æ•°è¯´æ˜
B: æ‰¹æ¬¡å¤§å°
N: æ¯ä¸ªæ ·æœ¬çš„å€™é€‰æ•°é‡ï¼ˆé»˜è®¤64ï¼‰
T: è½¨è¿¹é•¿åº¦ï¼ˆé»˜è®¤64æ—¶é—´æ­¥ï¼‰
2: 2Dç©ºé—´ï¼ˆx, yåæ ‡ï¼‰
```

### 6.4 æ€§èƒ½æŒ‡æ ‡

#### æ¨ç†é€Ÿåº¦
```
é…ç½®: RTX 3090, batch_size=1, N=64
  â”œâ”€ Transformer (8å±‚, 256ç»´): ~50ms
  â”œâ”€ U-Net1D (4å±‚): ~30ms
  â””â”€ å«B-splineå¹³æ»‘: +10ms
```

#### æ¨¡å‹è§„æ¨¡
```
FlowMPTransformer:
  â”œâ”€ å‚æ•°é‡: ~12M (baseé…ç½®)
  â”œâ”€ æ˜¾å­˜å ç”¨: ~500MB (æ¨ç†)
  â””â”€ è®­ç»ƒæ˜¾å­˜: ~4GB (batch_size=32)

CostMapEncoder:
  â”œâ”€ å‚æ•°é‡: ~2M
  â””â”€ æ˜¾å­˜å ç”¨: ~100MB
```

### 6.5 L2å±‚ä½¿ç”¨å»ºè®®

#### è®­ç»ƒæ•°æ®å‡†å¤‡
```
æ¨èæ•°æ®è§„æ¨¡:
  â”œâ”€ æœ€å°: 5,000 è½¨è¿¹æ ·æœ¬ï¼ˆåˆæˆæ•°æ®éªŒè¯ï¼‰
  â”œâ”€ åŸºç¡€: 50,000 è½¨è¿¹æ ·æœ¬ï¼ˆçœŸå®åœºæ™¯è®­ç»ƒï¼‰
  â””â”€ ç”Ÿäº§: 500,000+ è½¨è¿¹æ ·æœ¬ï¼ˆå¤æ‚ç¯å¢ƒï¼‰

æ•°æ®å¤šæ ·æ€§:
  âœ“ ä¸åŒåœºæ™¯ç±»å‹ï¼ˆå®¤å†…ã€å®¤å¤–ã€æ··åˆï¼‰
  âœ“ å¤šç§éšœç¢ç‰©é…ç½®
  âœ“ ä¸åŒæ§åˆ¶é£æ ¼çš„è½¨è¿¹
  âœ“ è¾¹ç•Œæƒ…å†µå’Œå›°éš¾åœºæ™¯
```

#### è¶…å‚æ•°è°ƒä¼˜
```
å…³é”®è¶…å‚æ•°:
  â”œâ”€ learning_rate: 1e-4 (Adam)
  â”œâ”€ num_layers: 6-8 (Transformer)
  â”œâ”€ hidden_dim: 256-512
  â”œâ”€ num_samples: 32-128 (æ¨ç†æ—¶)
  â””â”€ lambda_vel, lambda_acc, lambda_jerk: å‡ä¸º1.0
```

#### éƒ¨ç½²å»ºè®®
```
å®æ—¶ç³»ç»Ÿ:
  â”œâ”€ ä½¿ç”¨8æ­¥éå‡åŒ€ODEè°ƒåº¦ï¼ˆå¿«é€Ÿï¼‰
  â”œâ”€ æ‰¹å¤„ç†å¤šä¸ªç›®æ ‡ç‚¹
  â”œâ”€ GPUæ¨ç†ï¼ˆCUDAï¼‰
  â”œâ”€ å¯é€‰ï¼šTensorRTä¼˜åŒ–
  â””â”€ å¼‚æ­¥ç”Ÿæˆä¸MPPIä¼˜åŒ–

ç¦»çº¿è§„åˆ’:
  â”œâ”€ ä½¿ç”¨50æ­¥å‡åŒ€è°ƒåº¦ï¼ˆç²¾ç¡®ï¼‰
  â”œâ”€ å¯ç”¨B-splineå¹³æ»‘
  â””â”€ ç”Ÿæˆæ›´å¤šå€™é€‰ï¼ˆN=128ï¼‰
```

---

## 6.6 L2å±‚æ—¶é—´ç¼–ç é«˜çº§ä¸»é¢˜

#### æ—¶é—´ç¼–ç çš„æ•°å­¦åŸºç¡€

**Flow Matchingä¸­çš„æ—¶é—´è¡¨ç¤º**ï¼š

åœ¨æ¡ä»¶æµåŒ¹é…ä¸­ï¼Œæµè·¯å¾„å®šä¹‰ä¸ºï¼š
$$\phi_t(x_0, x_1) = t \cdot x_1 + (1-t) \cdot x_0, \quad t \in [0, 1]$$

é€Ÿåº¦åœºçš„å­¦ä¹ ç›®æ ‡ä¸ºï¼š
$$v_\theta(x_t, t) \approx x_1 - x_0$$

å…³é”®ç‚¹ï¼š**æ¨¡å‹å¿…é¡»å¯¹æ—¶é—´ $t$ æ•æ„Ÿ**

æ—¶é—´ç¼–ç å‡½æ•°å°†æ ‡é‡ $t$ æ˜ å°„åˆ°é«˜ç»´å‘é‡ï¼š
$$\text{time\_emb}(t) = [e_1(t), e_2(t), ..., e_d(t)]$$

å…¶ä¸­ $e_i$ æ˜¯ä¸åŒé¢‘ç‡çš„åŸºå‡½æ•°ï¼ˆFourieræˆ–Sinusoidalï¼‰ã€‚

#### é¢‘ç‡å¤šæ ·æ€§çš„é‡è¦æ€§

```
ã€ä¸åŒé¢‘ç‡çš„æ—¶é—´ç‰¹å¾ã€‘

ä½é¢‘ç‰¹å¾ (ç¼“æ…¢å˜åŒ–):
  â”œâ”€ æ•æ‰å…¨å±€æ—¶é—´è¿›åº¦
  â”œâ”€ è¡¨ç¤º"æ—©æœŸå»å™ª"vs"åæœŸç»†åŒ–"
  â””â”€ å¯¹åº”å¤§å°ºåº¦è½¨è¿¹ç‰¹å¾

ä¸­é¢‘ç‰¹å¾ (ä¸­ç­‰é€Ÿåº¦):
  â”œâ”€ æ•æ‰æ—¶é—´çš„ä¸­å±‚ä¿¡æ¯
  â”œâ”€ åè°ƒçŸ­æœŸåŠ¨æ€çº¦æŸ
  â””â”€ è¿æ¥å…¨å±€å’Œå±€éƒ¨

é«˜é¢‘ç‰¹å¾ (å¿«é€Ÿå˜åŒ–):
  â”œâ”€ æ•æ‰ç²¾ç»†æ—¶é—´ç»†èŠ‚
  â”œâ”€ å¯¹åº”å±€éƒ¨è½¨è¿¹æ›²ç‡ã€é€Ÿåº¦å˜åŒ–
  â””â”€ æ”¯æŒé«˜ç²¾åº¦æ—¶é—´é‡‡æ ·

è§†è§‰åŒ–ï¼š
  
æ—¶é—´è¿›åº¦ t
  0.0    0.25   0.5    0.75   1.0
  â”‚      â”‚      â”‚      â”‚      â”‚
  â†“      â†“      â†“      â†“      â†“
ä½é¢‘:  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (ä¸€ä¸ªå‘¨æœŸ)
  
ä¸­é¢‘:  â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€ (3-4ä¸ªå‘¨æœŸ)
  
é«˜é¢‘:  â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€ (8+ ä¸ªå‘¨æœŸ)
```

#### Fourier vs Sinusoidal ç¼–ç çš„é€‰æ‹©

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æŒ‡æ ‡            â”‚  Fourierç¼–ç       â”‚  Sinusoidalç¼–ç   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ é¢‘ç‡èŒƒå›´         â”‚ éšæœºé‡‡æ ·          â”‚ å›ºå®šå¯¹æ•°é—´è·     â”‚
â”‚ é«˜é¢‘è¡¨ç¤ºåŠ›       â”‚ æ›´å¼ºï¼ˆscale=30ï¼‰  â”‚ ä¸­ç­‰              â”‚
â”‚ å‚æ•°æ•°é‡         â”‚ å°‘ï¼ˆWå‘é‡ï¼‰       â”‚ å¤šï¼ˆMLPï¼‰        â”‚
â”‚ è®¡ç®—æ•ˆç‡         â”‚ é«˜                â”‚ ä¸­ç­‰              â”‚
â”‚ å¯å­¦ä¹ æ€§         â”‚ å¯é€‰              â”‚ ä¸å¯å­¦ä¹          â”‚
â”‚ é€‚ç”¨åœºæ™¯         â”‚ é€šç”¨ï¼ˆæ¨èï¼‰      â”‚ å›ºå®šç¦»æ•£æ—¶é—´     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### æ—¶é—´ç¼–ç è°ƒè¯•æŠ€å·§

```python
# 1. æ£€æŸ¥æ—¶é—´ç¼–ç çš„è¦†ç›–èŒƒå›´
from cfm_flowmp.models.embeddings import GaussianFourierProjection

encoder = GaussianFourierProjection(embed_dim=256, scale=30.0)

# é‡‡æ ·æ•´ä¸ª[0, 1]èŒƒå›´
t_samples = torch.linspace(0, 1, 1000).unsqueeze(-1)
embeddings = encoder(t_samples)  # [1000, 256]

# æ£€æŸ¥å„ç‰¹å¾çš„èŒƒå›´
print("ç‰¹å¾æœ€å°å€¼:", embeddings.min(dim=0).values[:10])  # å‰10ä¸ªç‰¹å¾
print("ç‰¹å¾æœ€å¤§å€¼:", embeddings.max(dim=0).values[:10])
print("ç‰¹å¾å‡å€¼:", embeddings.mean(dim=0)[:10])
print("ç‰¹å¾æ ‡å‡†å·®:", embeddings.std(dim=0)[:10])

# é¢„æœŸï¼šå¤§å¤šæ•°ç‰¹å¾åº”åœ¨ [-1, 1] èŒƒå›´å†…ï¼ˆsin/cosè¾“å‡ºï¼‰

# 2. æ£€æŸ¥æ—¶é—´æ•æ„Ÿæ€§
t1 = torch.tensor([[0.5]])
t2 = torch.tensor([[0.50001]])

emb1 = encoder(t1)
emb2 = encoder(t2)

distance = (emb1 - emb2).norm()
print(f"æ—¶é—´å·® 1e-5 å¯¹åº”çš„ç‰¹å¾å·®: {distance:.6f}")

# é¢„æœŸï¼šåº”è¯¥å¾ˆå°ï¼Œä½†ä¸ä¸ºé›¶ï¼ˆè¿ç»­ä½†å¯åŒºåˆ†ï¼‰

# 3. å¯è§†åŒ–é¢‘ç‡å“åº”
import matplotlib.pyplot as plt

t_range = torch.linspace(0, 1, 1000).unsqueeze(-1)
embeddings = encoder(t_range)

plt.figure(figsize=(14, 8))

# ç»˜åˆ¶å‰12ä¸ªç‰¹å¾
for i in range(12):
    plt.subplot(3, 4, i+1)
    plt.plot(t_range.numpy(), embeddings[:, i].numpy())
    plt.title(f'Feature {i}')
    plt.xlabel('Time t')
    plt.ylabel('Value')
    plt.grid(True)

plt.tight_layout()
plt.show()

# é¢„æœŸï¼šè§‚å¯Ÿå¤šé¢‘ç‡çš„å‘¨æœŸæ€§å˜åŒ–
```

#### æ—¶é—´ç¼–ç ä¸æ¡ä»¶èåˆçš„æœ€ä½³å®è·µ

```python
# âŒ ä¸å¥½çš„åšæ³•1ï¼šæ—¶é—´ä¿¡æ¯ä¸¢å¤±
def bad_condition_fusion(time_emb, spatial_cond):
    # ç›´æ¥å¿½ç•¥æ—¶é—´
    return spatial_cond  # æ—¶é—´ä¿¡æ¯ä¸¢å¤±ï¼

# âŒ ä¸å¥½çš„åšæ³•2ï¼šæ—¶é—´ä¿¡æ¯è¢«æ·¹æ²¡
def bad_condition_fusion(time_emb, spatial_cond):
    # ç®€å•æ‹¼æ¥ï¼Œä½†spatial_condç»´åº¦è¿‡å¤§
    return torch.cat([time_emb, spatial_cond], dim=-1)
    # é—®é¢˜ï¼šspatial_condå¯èƒ½å®Œå…¨å‹åˆ¶time_embçš„å½±å“

# âœ… å¥½çš„åšæ³•ï¼šåˆ†ç¦»ä¸”å¹³è¡¡çš„èåˆ
def good_condition_fusion(time_emb, x_curr, x_goal, e_map, w_style):
    B = time_emb.shape[0]
    
    # 1. åˆ†åˆ«ç¼–ç å„æ¡ä»¶åˆ†é‡
    state_enc = MLP([time_emb.shape[1], 128, 128])(time_emb)  # [B, 128]
    goal_enc = MLP([x_goal.shape[1], 128, 128])(x_goal)       # [B, 128]
    map_enc = e_map  # å·²æ˜¯[B, 256]
    style_enc = MLP([w_style.shape[1], 64])(w_style)          # [B, 64]
    
    # 2. æ‹¼æ¥ï¼ˆç»´åº¦ç›¸å¯¹å‡è¡¡ï¼‰
    combined = torch.cat([
        time_emb,      # [B, 256] - æ—¶é—´ä¿¡æ¯æ ¸å¿ƒ
        state_enc,     # [B, 128]
        goal_enc,      # [B, 128]
        map_enc,       # [B, 256]
        style_enc,     # [B, 64]
    ], dim=-1)  # [B, 832]
    
    # 3. æœ€ç»ˆæŠ•å½±åˆ°ç»Ÿä¸€ç»´åº¦
    cond = MLP([832, 512, 256])(combined)  # [B, 256]
    
    return cond

# âœ… æ›´é«˜çº§ï¼šä½¿ç”¨æ³¨æ„åŠ›åŠ æƒ
class AttentiveConditionFusion(nn.Module):
    def forward(self, time_emb, x_curr, x_goal, e_map, w_style):
        # å„æ¡ä»¶çš„é‡è¦æ€§æƒé‡ï¼ˆå¯å­¦ä¹ ï¼‰
        weights = self.compute_attention_weights({
            'time': time_emb,
            'state': self.state_proj(x_curr),
            'goal': self.goal_proj(x_goal),
            'map': e_map,
            'style': self.style_proj(w_style),
        })
        
        # åŠ æƒèåˆ
        weighted_cond = sum(
            w * cond for w, cond in zip(weights.values(), [time_emb, ...])
        )
        
        return weighted_cond
```

#### æ—¶é—´ç¼–ç çš„å‚æ•°æ•æ„Ÿæ€§

```
ã€Fourierç¼–ç å‚æ•°å¯¹æ€§èƒ½çš„å½±å“ã€‘

embed_dim (åŸºç¡€ç»´åº¦):
  â”œâ”€ å° (32): å¿«é€Ÿä½†è¡¨è¾¾åŠ›æœ‰é™
  â”œâ”€ ä¸­ (256): å¹³è¡¡æ€§èƒ½å’Œè¡¨è¾¾åŠ›ï¼ˆæ¨èï¼‰
  â””â”€ å¤§ (512): å¼ºè¡¨è¾¾åŠ›ä½†è®¡ç®—æˆæœ¬é«˜

scale (é¢‘ç‡æ ‡å‡†å·®):
  â”œâ”€ å° (5.0): é¢‘ç‡é›†ä¸­ï¼Œè¦†ç›–èŒƒå›´çª„
  â”œâ”€ ä¸­ (30.0): è‰¯å¥½çš„é¢‘ç‡åˆ†å¸ƒï¼ˆæ¨èï¼‰
  â””â”€ å¤§ (100.0): é¢‘ç‡åˆ†æ•£ï¼Œå¯èƒ½è¿‡åº¦å¹³æ»‘

ã€è¶…å‚æ•°å»ºè®®ã€‘

å¯¹äºL2å±‚ï¼ˆ256ç»´éšç©ºé—´ï¼‰:
  â”œâ”€ embed_dim = 256
  â”œâ”€ scale = 30.0
  â”œâ”€ time_embed_dim = 256 (è¾“å‡ºç»´åº¦)
  â””â”€ è¿™æ ·time_embä¸spatial_condç»´åº¦ä¸€è‡´

å¯¹äºä¸åŒè§„æ¨¡çš„æ¨¡å‹:
  â”œâ”€ å°æ¨¡å‹ (hidden_dim=128):
  â”‚   â””â”€ embed_dim=128, scale=20.0, time_embed_dim=128
  â”‚
  â”œâ”€ åŸºç¡€æ¨¡å‹ (hidden_dim=256):
  â”‚   â””â”€ embed_dim=256, scale=30.0, time_embed_dim=256 (æ¨è)
  â”‚
  â””â”€ å¤§æ¨¡å‹ (hidden_dim=512):
      â””â”€ embed_dim=512, scale=40.0, time_embed_dim=512
```

---

   - åŸºç¡€ç†è®ºæ¡†æ¶

2. **Diffusion Models**: "Denoising Diffusion Probabilistic Models" (2020)
   - ç”Ÿæˆæ¨¡å‹åŸºç¡€

3. **Transformers**: "Attention is All You Need" (2017)
   - æ¨¡å‹æ¶æ„åŸºç¡€

### ç›¸å…³é¡¹ç›®

- [Score-Based Generative Models](https://github.com/yang-song/score_sde)
- [Diffusion-Transformer](https://github.com/openai/guided-diffusion)
- [Motion Matching](https://research.cs.wisc.edu/graphics/Papers/2012/Holden12/)

### æœ‰ç”¨é“¾æ¥

- å®˜æ–¹æ–‡æ¡£ï¼š[ç¨åæ·»åŠ ]
- è®ºæ–‡é“¾æ¥ï¼š[ç¨åæ·»åŠ ]
- è®¨è®ºç¤¾åŒºï¼š[ç¨åæ·»åŠ ]

---

## ä¸ƒã€è´¡çŒ®æŒ‡å—

æˆ‘ä»¬æ¬¢è¿ç¤¾åŒºçš„è´¡çŒ®ï¼ä»¥ä¸‹æ˜¯å¦‚ä½•å‚ä¸çš„æ–¹å¼ï¼š

### æŠ¥å‘Š Bug
1. æ£€æŸ¥ GitHub Issues æ˜¯å¦å·²å­˜åœ¨ç›¸åŒé—®é¢˜
2. åˆ›å»ºæ–° Issueï¼Œæä¾›ä»¥ä¸‹ä¿¡æ¯ï¼š
   - å¤ç°æ­¥éª¤
   - é¢„æœŸè¡Œä¸º vs å®é™…è¡Œä¸º
   - Python/PyTorch ç‰ˆæœ¬
   - é”™è¯¯æ—¥å¿—

### æå‡ºåŠŸèƒ½è¯·æ±‚
1. æè¿°æ–°åŠŸèƒ½çš„ç”¨é€”
2. æä¾›ç®€è¦çš„å®ç°æ€è·¯
3. è®¨è®ºå¯èƒ½çš„ API è®¾è®¡

### ä»£ç è´¡çŒ®
1. Fork ä»“åº“
2. åˆ›å»ºç‰¹æ€§åˆ†æ”¯ï¼š`git checkout -b feature/your-feature`
3. éµå¾ªä»£ç é£æ ¼ (è§ä¸‹)
4. æäº¤ PR å¹¶æè¿°æ”¹åŠ¨

### ä»£ç é£æ ¼æŒ‡å—

```python
# ç±»çš„å®šä¹‰
class MyModel(torch.nn.Module):
    """ç®€æ´çš„ç±»æ–‡æ¡£å­—ç¬¦ä¸²"""
    
    def __init__(self, config: Dict):
        super().__init__()
        # åˆå§‹åŒ–ä»£ç 
    
    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """å‡½æ•°æ–‡æ¡£è¯´æ˜å‚æ•°å’Œè¿”å›å€¼"""
        return x

# å‡½æ•°å‘½åï¼šsnake_case
def compute_flow_matching_loss(pred, target) -> torch.Tensor:
    pass

# å¸¸æ•°ï¼šUPPER_CASE
DEFAULT_LEARNING_RATE = 1e-4
MAX_SEQ_LENGTH = 512
```

---

## å…«ã€è®¸å¯å’Œå¼•ç”¨

### è®¸å¯

æœ¬é¡¹ç›®é‡‡ç”¨ [MIT License](LICENSE)

### å¼•ç”¨

å¦‚æœä½¿ç”¨æœ¬é¡¹ç›®ï¼Œè¯·åœ¨è®ºæ–‡ä¸­å¼•ç”¨ï¼š

```bibtex
@misc{cfm-flowmp-2026,
  title={CFM FlowMP: Conditional Flow Matching for Trajectory Planning},
  author={Your Name},
  year={2026},
  howpublished={\url{https://github.com/your-repo}}
}
```

---

**æœ€åæ›´æ–°**: 2026 å¹´ 1 æœˆ 31 æ—¥  
**æ–‡æ¡£ç‰ˆæœ¬**: 2.0  
**é¡¹ç›®ç‰ˆæœ¬**: v1.0.0

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    è®­ç»ƒæ•°æ®æµ                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[1] æ•°æ®åŠ è½½ (dataset.py)
    â”‚
    â”œâ”€ TrajectoryDataset: ä»æ–‡ä»¶åŠ è½½ä¸“å®¶è½¨è¿¹
    â”‚   â”œâ”€ æ”¯æŒæ ¼å¼: .npy, .npz, .h5, .pkl
    â”‚   â”œâ”€ è¾“å…¥: positions [N, T, D]
    â”‚   â”œâ”€ è‡ªåŠ¨è®¡ç®—: velocities, accelerations (å¦‚æœç¼ºå¤±)
    â”‚   â””â”€ è¾“å‡º: å½’ä¸€åŒ–çš„è½¨è¿¹æ•°æ®
    â”‚
    â””â”€ SyntheticTrajectoryDataset: ç”Ÿæˆåˆæˆè½¨è¿¹
        â”œâ”€ Bezier æ›²çº¿
        â”œâ”€ å¤šé¡¹å¼è½¨è¿¹
        â””â”€ æ­£å¼¦è¿åŠ¨

[2] æ•°æ®é¢„å¤„ç†
    â”‚
    â”œâ”€ å½’ä¸€åŒ–: (x - mean) / std
    â”œâ”€ æå–æ¡ä»¶: start_pos, goal_pos, start_vel
    â””â”€ æ‰¹æ¬¡åŒ–: DataLoader

[3] Flow Matching è®­ç»ƒå¾ªç¯ (flow_matching.py)
    â”‚
    â”œâ”€ æ­¥éª¤ 1: é‡‡æ ·æµæ—¶é—´ t ~ Uniform(0, 1)
    â”‚
    â”œâ”€ æ­¥éª¤ 2: é‡‡æ ·å™ªå£°
    â”‚   â”œâ”€ Îµ_q ~ N(0, I)      [B, T, D]  ä½ç½®å™ªå£°
    â”‚   â”œâ”€ Îµ_q_dot ~ N(0, I)  [B, T, D]  é€Ÿåº¦å™ªå£°
    â”‚   â””â”€ Îµ_q_ddot ~ N(0, I) [B, T, D]  åŠ é€Ÿåº¦å™ªå£°
    â”‚
    â”œâ”€ æ­¥éª¤ 3: çŠ¶æ€æ’å€¼ (çº¿æ€§æ’å€¼è·¯å¾„)
    â”‚   â”œâ”€ q_t = t * q_1 + (1-t) * Îµ_q
    â”‚   â”œâ”€ q_dot_t = t * q_dot_1 + (1-t) * Îµ_q_dot
    â”‚   â””â”€ q_ddot_t = t * q_ddot_1 + (1-t) * Îµ_q_ddot
    â”‚
    â”œâ”€ æ­¥éª¤ 4: è®¡ç®—ç›®æ ‡å‘é‡åœº
    â”‚   â”œâ”€ u_target = (q_1 - q_t) / (1-t)      # ä½ç½®é€Ÿåº¦åœº
    â”‚   â”œâ”€ v_target = (q_dot_1 - q_dot_t) / (1-t)  # é€Ÿåº¦åŠ é€Ÿåº¦åœº
    â”‚   â””â”€ w_target = (q_ddot_1 - q_ddot_t) / (1-t) # åŠ é€Ÿåº¦åŠ åŠ é€Ÿåº¦åœº
    â”‚
    â”œâ”€ æ­¥éª¤ 5: æ¨¡å‹å‰å‘ä¼ æ’­ (transformer.py)
    â”‚   â”œâ”€ è¾“å…¥: x_t = [q_t, q_dot_t, q_dot_t] [B, T, 6]
    â”‚   â”œâ”€ æ¡ä»¶: start_pos, goal_pos, start_vel
    â”‚   â”œâ”€ æ—¶é—´åµŒå…¥: Gaussian Fourier Projection
    â”‚   â”œâ”€ Transformer Blocks (AdaLN æ¡ä»¶åŒ–)
    â”‚   â””â”€ è¾“å‡º: [u_pred, v_pred, w_pred] [B, T, 6]
    â”‚
    â””â”€ æ­¥éª¤ 6: æŸå¤±è®¡ç®—
        â”œâ”€ L_vel = ||u_pred - u_target||Â²
        â”œâ”€ L_acc = ||v_pred - v_target||Â²
        â”œâ”€ L_jerk = ||w_pred - w_target||Â²
        â””â”€ L_total = Î»_vel*L_vel + Î»_acc*L_acc + Î»_jerk*L_jerk
```

### 2. æ¨ç†é˜¶æ®µæ•°æ®æµ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ¨ç†æ•°æ®æµ                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[1] åˆå§‹åŒ–
    â”‚
    â”œâ”€ è¾“å…¥æ¡ä»¶: start_pos [B, D], goal_pos [B, D], start_vel [B, D]
    â””â”€ é‡‡æ ·åˆå§‹å™ªå£°: x_0 ~ N(0, I) [B, T, 6]

[2] ODE æ±‚è§£ (ode_solver.py)
    â”‚
    â”œâ”€ æ—¶é—´è°ƒåº¦:
    â”‚   â”œâ”€ å‡åŒ€è°ƒåº¦: t = [0, dt, 2*dt, ..., 1]
    â”‚   â””â”€ 8æ­¥éå‡åŒ€è°ƒåº¦: [0.0, 0.8, 0.85, 0.9, 0.92, 0.94, 0.96, 0.98, 1.0]
    â”‚       (æ—©æœŸå¤§æ­¥é•¿ï¼ŒåæœŸå°æ­¥é•¿ï¼Œä¿ç•™ç»†èŠ‚)
    â”‚
    â”œâ”€ RK4 ç§¯åˆ†æ­¥éª¤:
    â”‚   â”œâ”€ k1 = model(x_t, t, conditions)
    â”‚   â”œâ”€ k2 = model(x_t + dt/2*k1, t + dt/2, conditions)
    â”‚   â”œâ”€ k3 = model(x_t + dt/2*k2, t + dt/2, conditions)
    â”‚   â”œâ”€ k4 = model(x_t + dt*k3, t + dt, conditions)
    â”‚   â””â”€ x_{t+dt} = x_t + dt/6*(k1 + 2*k2 + 2*k3 + k4)
    â”‚
    â””â”€ ä» t=0 ç§¯åˆ†åˆ° t=1 â†’ x_1

[3] æå–è½¨è¿¹
    â”‚
    â”œâ”€ positions = x_1[..., :D]      [B, T, D]
    â”œâ”€ velocities = x_1[..., D:2*D] [B, T, D]
    â””â”€ accelerations = x_1[..., 2*D:3*D] [B, T, D]

[4] åå¤„ç†å¹³æ»‘ (generator.py)
    â”‚
    â””â”€ B-spline å¹³æ»‘ (å¯é€‰)
        â”œâ”€ æ‹Ÿåˆ B-spline æ›²çº¿
        â”œâ”€ é‡æ–°é‡‡æ ·å¹³æ»‘è½¨è¿¹
        â””â”€ è®¡ç®—å¹³æ»‘åçš„é€Ÿåº¦å’ŒåŠ é€Ÿåº¦
```

### 3. æ¨¡å‹æ¶æ„æ•°æ®æµ

```
è¾“å…¥: x_t [B, T, 6] (ä½ç½®+é€Ÿåº¦+åŠ é€Ÿåº¦)
      t [B] (æµæ—¶é—´)
      c (start_pos, goal_pos, start_vel)

    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Input Projection                  â”‚
â”‚   [B, T, 6] â†’ [B, T, hidden_dim]   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Positional Encoding               â”‚
â”‚   (Sinusoidal/Learned)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Gaussian Fourier Time Embedding  â”‚
â”‚   t â†’ [B, hidden_dim]               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚    â”‚  Condition Encoder   â”‚
           â”‚    â”‚  c â†’ [B, hidden_dim] â”‚
           â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚               â”‚
           â†“               â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Combined Conditioning    â”‚
    â”‚  [time_emb + cond_emb]    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                           â”‚
    â†“                           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
â”‚  Transformer Blocks (Ã—L)             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  AdaLN (conditioned on t, c)  â”‚ â”‚
â”‚  â”‚         â†“                      â”‚ â”‚
â”‚  â”‚  Multi-Head Self-Attention     â”‚ â”‚
â”‚  â”‚         â†“                      â”‚ â”‚
â”‚  â”‚  AdaLN (conditioned on t, c)  â”‚ â”‚
â”‚  â”‚         â†“                      â”‚ â”‚
â”‚  â”‚  Feed-Forward Network          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Final AdaLN                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Output Head                       â”‚
â”‚   [B, T, hidden_dim] â†’ [B, T, 6]    â”‚
â”‚   (u: é€Ÿåº¦åœº, v: åŠ é€Ÿåº¦åœº, w: åŠ åŠ é€Ÿåº¦åœº)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

**æœ€åæ›´æ–°**: 2026 å¹´ 1 æœˆ 31 æ—¥  
**æ–‡æ¡£ç‰ˆæœ¬**: 2.0  
**é¡¹ç›®ç‰ˆæœ¬**: v1.0.0